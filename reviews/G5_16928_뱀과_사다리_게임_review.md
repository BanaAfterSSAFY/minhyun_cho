---
title: "[리뷰] G5_16928_뱀과_사다리_게임.java"
date: 2026-02-02
tags: [Algorithm, Java]
---

안녕하세요, 알고리즘 탐험가 여러분! 오늘은 백준 온라인 저지에서 인기 있는 그래프 탐색 문제 중 하나인 "16928 뱀과 사다리 게임" 문제의 Java 풀이를 함께 분석해보는 시간을 갖겠습니다. 이 문제는 최단 경로를 찾는 전형적인 BFS(Breadth-First Search) 문제로, BFS의 기본 원리를 이해하는 데 아주 좋은 예시가 됩니다.

---

## 🐍🎲 백준 16928: 뱀과 사다리 게임 (Java BFS 풀이)

### 1. 문제 요약 및 풀이 전략

**문제 요약:**
1번 칸에서 시작하여 100번 칸에 도착하기 위해 주사위를 굴려야 하는 최소 횟수를 찾는 문제입니다. 주사위는 1부터 6까지 나올 수 있으며, 주사위를 굴려 도착한 칸에 뱀이나 사다리가 있다면 해당 뱀/사다리의 목적지 칸으로 이동합니다.

**풀이 전략: BFS (너비 우선 탐색)**
최소 횟수를 구하는 문제이므로, 가장 먼저 떠올려야 할 알고리즘은 BFS입니다. BFS는 시작점에서부터 거리가 1인 노드들을 먼저 탐색하고, 이어서 거리가 2인 노드들을 탐색하는 방식으로 동작하므로, 목표 지점에 처음 도달했을 때의 횟수가 곧 최단 경로의 횟수가 됩니다.

1.  **그래프 모델링:**
    *   각 칸(1번부터 100번)을 그래프의 **노드(Node)**로 생각합니다.
    *   주사위를 굴려 이동할 수 있는 경우를 **간선(Edge)**으로 생각합니다. 즉, 현재 `x`칸에 있다면 주사위를 굴려 `x+1`, `x+2`, ..., `x+6` 칸으로 이동할 수 있습니다.
2.  **BFS 탐색:**
    *   **큐 (Queue):** 탐색할 칸과 그 칸에 도달하기까지의 주사위 굴림 횟수를 저장합니다. `[현재 칸, 주사위 굴림 횟수]` 형태가 될 것입니다.
    *   **방문 배열 (isVisited):** 이미 방문한 칸은 다시 방문하지 않도록 표시하여 중복 탐색을 방지하고, 최단 경로임을 보장합니다.
    *   **특별 이동 (뱀/사다리):** `arr` 배열을 사용하여 특정 칸에 도착했을 때 뱀이나 사다리로 인해 강제로 이동해야 하는 목적지를 저장합니다. `arr[x] = y`는 x칸에 도착하면 y칸으로 이동해야 함을 의미합니다. (값이 0이면 일반 칸)
    *   **탐색 과정:**
        1.  시작 칸(1번)과 굴림 횟수(0)를 큐에 넣고 방문 처리합니다.
        2.  큐에서 하나를 꺼냅니다. `(curr_pos, curr_count)`
        3.  `curr_pos`가 100번 칸이라면, `curr_count`가 정답이므로 출력하고 종료합니다.
        4.  주사위를 1부터 6까지 굴려 `next_pos`를 계산합니다.
        5.  `next_pos`가 100을 넘지 않고, 아직 방문하지 않은 칸이라면:
            *   `next_pos`가 뱀/사다리의 시작 칸인지 `arr[next_pos]`를 확인합니다. 만약 그렇다면 `next_pos`를 `arr[next_pos]`의 목적지 칸으로 업데이트합니다. (여기서 한 번의 뱀/사다리 이동만 고려합니다.)
            *   업데이트된 `next_pos`를 `curr_count + 1`과 함께 큐에 넣고 방문 처리합니다.

---

### 2. 시간 복잡도와 공간 복잡도 분석

**시간 복잡도 (Time Complexity): O(V + E)**
BFS의 일반적인 시간 복잡도는 `O(V + E)`입니다. 여기서:
*   `V` (Vertex, 정점): 게임판의 칸 수. 1번부터 100번까지 총 100개의 칸이므로 `V = 100`입니다.
*   `E` (Edge, 간선): 각 칸에서 이동할 수 있는 경우의 수. 주사위 눈금 1~6에 따라 최대 6개의 다음 칸으로 이동할 수 있습니다. 뱀/사다리로 인한 이동은 한 칸에서 다음 칸으로 이동하는 과정에 포함되므로, 여전히 6가지 주사위 눈금에 따른 이동을 탐색합니다.
*   따라서, 각 노드는 최대 한 번만 큐에 들어가고 나오며, 나올 때마다 6번의 반복문이 실행됩니다.
*   최악의 경우 `100 * 6`번의 연산이 발생할 수 있습니다. 이는 `O(600)`으로, 사실상 **O(1)**에 가까운 매우 효율적인 상수로 볼 수 있습니다.

**공간 복잡도 (Space Complexity): O(V)**
*   `arr` 배열: 101개의 int 값을 저장합니다. (`O(V)`)
*   `isVisited` 배열: 101개의 boolean 값을 저장합니다. (`O(V)`)
*   `que`: 큐에는 최악의 경우 모든 칸이 한 번에 들어가 있을 수 있습니다 (예: 외곽을 돌아서 가는 경우). 따라서 큐에 저장될 수 있는 원소의 최대 개수는 칸의 개수와 비례합니다. (`O(V)`)
*   총 공간 복잡도는 `O(V) = O(100)`으로, 이 또한 사실상 **O(1)**에 가까운 상수 공간입니다.

결론적으로, 이 풀이는 주어진 문제의 제약 조건(칸 수 100개) 하에서 매우 효율적인 시간과 공간 복잡도를 가집니다.

---

### 3. 코드에서 개선할 점이나 주의해야 할 예외 케이스(Edge Case)

제시된 코드는 뱀과 사다리 게임의 BFS 풀이로서 매우 잘 작성되어 있으며, 일반적인 경쟁 프로그래밍 환경에서는 이대로 제출해도 전혀 문제없습니다. 몇 가지 관점에서 더 살펴보겠습니다.

1.  **가독성 및 변수명:**
    *   `arr`: 뱀과 사다리의 이동 정보를 저장하는 배열입니다. `jumpMap`이나 `teleportPoints`와 같이 그 역할을 더 명확히 드러내는 변수명을 사용하면 코드의 의도를 파악하는 데 도움이 될 수 있습니다. 하지만 `arr`도 일반적으로 사용되는 짧은 변수명이라 괜찮습니다.
    *   큐에 저장하는 `int[] {current_square, dice_count}`는 주석으로 설명되어 있어 좋습니다. Java 16 이상에서는 `record`를 사용하여 `record Position(int square, int count) {}`와 같이 정의하면 더욱 안전하고 가독성 높은 코드를 작성할 수 있습니다. 그러나 코딩 테스트에서는 `int[]`가 빠르고 간편하여 자주 사용됩니다.

2.  **예외 케이스(Edge Case) 처리:**
    *   **100번 칸 초과:** `if(next <= 100)` 조건으로 주사위를 굴려 100번 칸을 넘어가는 경우를 정확히 처리합니다. (100번 칸을 초과하면 이동할 수 없습니다.)
    *   **뱀/사다리 이동:** `if(arr[next] != 0) next = arr[next];` 이 로직은 `next` 칸이 뱀이나 사다리의 시작 지점일 경우, 즉시 목적지 칸으로 이동시키는 역할을 정확히 수행합니다. 이 문제에서는 뱀/사다리로 이동한 칸이 또 다른 뱀/사다리의 시작 지점일 경우 *추가 이동하지 않고* 해당 칸에 머무는 것으로 해석됩니다. 현재 코드는 이 해석을 따릅니다 (한 번의 점프만 수행).
    *   **방문 처리:** `if(!isVisited[next])` 조건으로 이미 방문한 칸은 다시 탐색하지 않도록 하여 최단 경로를 보장하고 무한 루프를 방지합니다. BFS의 핵심적인 부분이며, 잘 구현되어 있습니다.

3.  **최소 개선점 (Minor Improvement):**
    *   `bfs` 함수의 `start` 매개변수가 항상 `1`로 고정되어 있습니다. 문제 조건상 시작 칸이 항상 1이라면, 이 매개변수를 없애고 `bfs` 함수 내부에서 `start = 1`로 초기화하거나, 매개변수를 유지하더라도 `main`에서만 `bfs(arr, isVisited, 1)`로 호출하면 됩니다. 현재 방식도 일반적인 BFS 함수 정의 방식이라 유연성을 제공합니다.
    *   `BufferedReader`와 `StringTokenizer` 사용은 입력이 많을 때 성능 상 이점을 제공하므로 좋은 습관입니다.

---

### 결론

주어진 "뱀과 사다리 게임" 풀이는 BFS의 기본 원리를 충실히 따르면서 문제의 특수 조건(뱀/사다리)을 깔끔하게 처리한 모범적인 코드입니다. 짧은 코드 안에 필요한 모든 로직(큐, 방문 배열, 주사위 굴림, 특수 이동 처리)이 잘 구현되어 있어 BFS를 학습하거나 최단 경로 문제를 해결하는 데 참고하기에 아주 훌륭한 예시입니다. 알고리즘 문제 풀이 시, 최단 경로 문제에서는 항상 BFS를 최우선으로 고려하고, 방문 배열과 큐를 활용하는 습관을 들이는 것이 중요합니다!

다음 포스팅에서 또 다른 흥미로운 알고리즘 문제로 찾아뵙겠습니다. 해피 코딩!