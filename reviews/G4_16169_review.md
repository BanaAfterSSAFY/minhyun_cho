---
title: "[리뷰] G4_16169.java"
date: 2026-02-27
tags: [Algorithm, Java]
---

안녕하세요, 알고리즘과 자료구조의 깊이를 탐구하는 테크 블로거, 알잘박사입니다! 🤓

오늘은 백준 온라인 저지 Gold 4 티어 문제인 **16169번 "수행 시간"** 풀이를 함께 분석해보려 합니다. 이 문제는 태스크 간의 복잡한 의존 관계와 전송 시간을 고려하여 전체 작업의 최대 완료 시간을 계산하는 문제입니다. 전형적인 **DAG(Directed Acyclic Graph)에서의 최장 경로(Critical Path) 찾기** 문제이지만, 그래프 구성 방식에 독특한 제약이 있어 주의가 필요합니다.

---

## 🚀 백준 16169번: 수행 시간 (G4_16169_수행_시간) 풀이 분석

### 1. 문제 요약 및 풀이 전략

이 문제는 `N`개의 태스크가 주어지고, 각 태스크는 **랭크(rank)**와 **수행 시간(processTime)**을 가집니다. 태스크 간의 의존 관계는 다음과 같습니다:

1.  어떤 태스크 `u`가 `r` 랭크에 속하고, 어떤 태스크 `v`가 `r+1` 랭크에 속한다면, `u`는 `v`의 선행 태스크가 됩니다. 즉, `u`가 완료되어야 `v`가 시작할 수 있습니다.
2.  이때, `u`의 결과가 `v`로 전송되는 데 걸리는 시간은 `(u의 ID - v의 ID)^2` 입니다.
3.  태스크 `v`는 모든 선행 태스크가 완료되고, 그 결과가 모두 전송되어야 시작할 수 있습니다.
4.  우리가 찾아야 할 것은 `N`개의 태스크 중 가장 늦게 완료되는 태스크의 완료 시간입니다.

**풀이 전략:**

이 문제는 태스크 간의 명확한 선후 관계(방향성)가 있고, 순환이 발생하지 않는다는 점에서 **DAG(Directed Acyclic Graph)** 문제임을 알 수 있습니다. 각 태스크의 완료 시간을 계산해야 하므로, 이는 DAG에서 **최장 경로(Critical Path)**를 찾는 전형적인 문제입니다.

이를 해결하기 위해 **위상 정렬(Topological Sort)과 동적 프로그래밍(Dynamic Programming)** 기법을 활용합니다.

1.  **그래프 구성:**
    *   먼저 각 태스크의 `rank`를 기준으로 그룹화합니다 (`rankGroups`).
    *   `r` 랭크의 모든 태스크는 `r+1` 랭크의 모든 태스크에 대해 의존성을 가집니다. 따라서, `rankGroups.get(r)`의 모든 `u`에서 `rankGroups.get(r+1)`의 모든 `v`로 향하는 간선을 추가합니다.
    *   이 과정에서 각 노드의 `진입 차수(in-degree)`를 계산하여 저장합니다.

2.  **DP(Dynamic Programming) 정의:**
    *   `dp[i]` = 태스크 `i`가 완료되는 최소 시간 (Critical Path 값).
    *   초기 `dp[i]` 값은 해당 태스크 `i`의 고유 수행 시간(`times[i]`)으로 설정합니다. 이는 선행 태스크가 없는 경우(진입 차수 0) 해당 태스크가 시작하자마자 자신의 수행 시간만큼 걸린다는 의미입니다.

3.  **위상 정렬 (Kahn's Algorithm):**
    *   진입 차수가 0인 모든 태스크를 큐에 넣고 위상 정렬을 시작합니다.
    *   큐에서 태스크 `curr`를 하나 꺼냅니다.
    *   `curr`의 완료 시간 `dp[curr]`가 현재까지의 `totalMaxTime`보다 크다면 업데이트합니다.
    *   `curr`가 완료되었으므로, `curr`를 선행 태스크로 가지는 모든 `next` 태스크들의 완료 시간을 업데이트할 차례입니다.
        *   `transferTime = (curr - next) * (curr - next)`를 계산합니다.
        *   `next` 태스크의 새로운 완료 가능 시간은 `dp[curr] + transferTime + times[next]` 입니다.
        *   `dp[next]`는 모든 선행 태스크 중 가장 늦게 끝나는 태스크에 맞춰져야 하므로, `dp[next] = Math.max(dp[next], dp[curr] + transferTime + times[next])`로 업데이트합니다.
        *   `next` 태스크의 진입 차수를 1 감소시킵니다.
        *   만약 `degree[next]`가 0이 되면, `next` 태스크는 모든 선행 태스크를 처리했으므로 큐에 추가합니다.

4.  **최종 결과:**
    *   위상 정렬이 모두 끝나면, `totalMaxTime`에 저장된 값이 전체 태스크 중 가장 늦게 완료되는 태스크의 시간, 즉 시스템 전체의 최대 수행 시간이 됩니다.

### 2. 시간 복잡도와 공간 복잡도 분석

**시간 복잡도:**

1.  **초기화 및 입력 처리:** `times`, `dp`, `degree`, `graph`, `rankGroups` 배열/리스트 초기화 및 태스크 정보 읽는 데 `O(N)` 시간이 소요됩니다. `maxRank`를 찾는 데도 `O(N)`입니다.
2.  **그래프 구성:**
    *   `for (int r = 1; r < maxRank; r++)` 루프는 `maxRank`번 실행됩니다.
    *   내부의 `for (int u : rankGroups.get(r))` 및 `for (int v : rankGroups.get(r + 1))` 루프는 `r` 랭크의 태스크 수와 `r+1` 랭크의 태스크 수를 곱한 만큼 간선을 추가합니다.
    *   최악의 경우, 모든 `N`개의 태스크가 단 두 개의 랭크(예: `N/2`개가 랭크 1, `N/2`개가 랭크 2)에 나뉘어 있다면, `(N/2) * (N/2) = N^2/4`개의 간선이 생성됩니다.
    *   따라서 그래프 구성은 최악의 경우 **`O(N^2)`** 입니다.
3.  **위상 정렬 (Kahn's Algorithm):**
    *   위상 정렬은 `O(V + E)`의 시간 복잡도를 가집니다. 여기서 `V`는 노드의 개수 `N`이고, `E`는 간선의 개수입니다.
    *   앞서 보았듯이 `E`는 최악의 경우 `O(N^2)`이 될 수 있습니다.
    *   따라서 위상 정렬 단계는 최악의 경우 **`O(N + N^2) = O(N^2)`** 입니다.

종합하면, 이 솔루션의 전체 시간 복잡도는 그래프 구성 및 위상 정렬이 지배하므로 **`O(N^2)`** 입니다.

**공간 복잡도:**

1.  `times`, `dp`, `degree` 배열: 각 `O(N)` 공간을 사용합니다.
2.  `graph` (인접 리스트): `O(V + E)` 공간을 사용합니다. `V`는 `N`, `E`는 최악의 경우 `O(N^2)`이므로, **`O(N^2)`** 공간을 사용합니다.
3.  `rankGroups` (랭크별 태스크 그룹): 모든 태스크 ID를 저장하므로 `O(N)` 공간을 사용합니다.
4.  `que` (큐): 최악의 경우 모든 태스크가 한 번에 큐에 들어갈 수 있으므로 `O(N)` 공간을 사용합니다.

종합하면, 이 솔루션의 전체 공간 복잡도는 `graph`의 크기에 의해 지배되므로 **`O(N^2)`** 입니다.

문제의 `N` 제한이 `1000`이므로, `N^2`는 `1000^2 = 1,000,000` (백만)입니다.
*   시간적으로 백만 번의 연산은 `1`초 내외로 충분히 가능합니다.
*   공간적으로 백만 개의 정수 배열이나 리스트는 대략 `4MB` 정도이므로, 메모리 제한(보통 `256MB` 또는 `512MB`) 내에 들어옵니다.

### 3. 코드에서 개선할 점이나 주의해야 할 예외 케이스(Edge Case)

**주의해야 할 예외 케이스 (Edge Case):**

1.  **`N=1`인 경우:**
    *   `maxRank`는 `1`이 될 것입니다.
    *   `for (int r = 1; r < maxRank; r++)` 루프는 실행되지 않습니다. (간선이 생성되지 않음)
    *   `degree[1]`은 `0`이므로 `que`에 `1`이 추가됩니다.
    *   `totalMaxTime`은 `dp[1]` (즉, `times[1]`)로 업데이트되고, 루프가 종료됩니다.
    *   정상적으로 `times[1]`이 출력됩니다. **문제없이 처리됩니다.**
2.  **모든 태스크가 동일한 랭크에 속하는 경우:**
    *   `maxRank`는 `1`이 될 것이고, 위와 마찬가지로 간선은 생성되지 않습니다.
    *   모든 태스크의 `degree`는 `0`이므로 모두 `que`에 들어갑니다.
    *   각 `dp[i]`는 `times[i]`이고, `totalMaxTime`은 이들 중 최댓값이 됩니다.
    *   정상적으로 처리됩니다 (서로 의존성이 없으므로 각자 수행 시간만 고려).
3.  **`dp` 값의 오버플로우:**
    *   `transferTime = (curr - next) * (curr - next)`는 최대 `(N-1)^2`까지 가능합니다. `N=1000`일 때 `999^2`는 대략 `10^6`입니다.
    *   `dp[next]`는 `dp[curr] + transferTime + times[next]`로 갱신됩니다.
    *   최장 경로의 길이가 `N`에 가깝고, 각 단계에서 `transferTime`과 `times[next]`가 최대치라면 `N * (N^2 + max_time)` 정도의 값이 될 수 있습니다.
    *   `1000 * (1000^2 + 1000)` = `1000 * (1,000,000 + 1000)` = `1000 * 1,001,000` = `1,001,000,000` (약 10억).
    *   `int` 타입의 최대값은 약 `2 * 10^9`이므로, `N=1000`일 때는 `int`로 충분합니다. 하지만 `N`이 조금 더 커져서 `2000` 이상이 된다면 `long` 타입을 사용하는 것이 안전합니다. 현재 코드에서는 `int`로 선언되어 있으므로, `N` 제약 조건 하에서는 문제가 없습니다.

**코드 개선점:**

현재 코드는 주어진 문제의 제약 조건 내에서 `O(N^2)`의 시간 및 공간 복잡도로 최적의 해를 찾아냅니다. 문제에서 명시된 **"모든 랭크 r의 태스크 u는 랭크 r+1의 모든 태스크 v의 선행 태스크"** 라는 조건 자체가 `N^2` 규모의 간선을 생성하게 만들기 때문에, 이를 `O(N log N)` 등으로 줄이는 것은 불가능합니다.

*   **가독성 측면:** 변수명이나 주석이 잘 되어 있어 크게 개선할 부분은 없어 보입니다.
*   **초기 `dp` 값:** `dp[i]`를 `times[i]`로 초기화한 부분이 매우 중요하고 올바릅니다. 진입 차수가 0인 노드 (가장 첫 랭크의 태스크)는 자신의 수행 시간만을 가지기 때문입니다.
*   **`rankGroups`의 사용:** `rankGroups`를 사용하여 랭크별 태스크를 효율적으로 관리하고, 그래프 구성 시 필요한 태스크들을 빠르게 참조하는 전략은 매우 좋습니다.

---

### 마치며

16169번 "수행 시간" 문제는 DAG에서의 최장 경로를 위상 정렬과 DP로 푸는 기본적인 접근법을 요구합니다. 하지만 "모든 태스크가 모든 다음 랭크 태스크의 선행 작업"이라는 독특한 제약 조건 때문에 그래프의 간선 수가 `O(N^2)`이 될 수 있다는 점을 이해하는 것이 중요했습니다. 이 조건 때문에 `O(N^2)` 시간/공간 복잡도가 필연적으로 발생하며, 주어진 `N` 범위 내에서는 이 해결책이 효율적입니다.

이러한 유형의 문제에 익숙해지면, 복잡한 의존성을 가진 시스템의 총 수행 시간이나 자원 할당 문제를 해결하는 데 큰 도움이 될 것입니다. 다음에도 흥미로운 알고리즘 문제 분석으로 찾아오겠습니다! 궁금한 점이 있다면 언제든지 댓글로 남겨주세요! 😊