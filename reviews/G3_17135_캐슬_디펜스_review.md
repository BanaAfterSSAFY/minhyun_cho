---
title: "[리뷰] G3_17135_캐슬_디펜스.java"
date: 2026-02-25
tags: [Algorithm, Java]
---

안녕하세요, 알고리즘 마스터! 오늘은 백준 온라인 저지에서 자주 볼 수 있는 시뮬레이션 및 탐색 유형의 문제, "캐슬 디펜스 (G3_17135)" 문제 풀이를 분석해보겠습니다. 주어진 Java 코드를 꼼꼼히 뜯어보고, 이 문제의 핵심 전략과 복잡도, 그리고 개선점까지 깊이 있게 파헤쳐 봅시다.

---

## 캐슬 디펜스: 완벽한 궁수 배치를 찾아라! (백준 17135)

캐슬 디펜스는 전형적인 완전 탐색(Brute Force)과 시뮬레이션 문제로, 제한된 조건 속에서 최적의 전략을 찾아야 하는 재미있는 퍼즐입니다. 궁수 3명의 배치에 따라 매 턴 죽일 수 있는 적의 수가 달라지므로, 모든 가능한 궁수 배치를 시도하고 각 시나리오별로 게임을 시뮬레이션하여 최대 킬 수를 구해야 합니다.

### 1. 문제 요약 및 풀이 전략

이 문제는 `N x M` 크기의 격자에서 진행됩니다. 궁수 3명은 `N`번 행, 즉 게임판 아래에 배치되며, 각 궁수는 자신으로부터 `D` 거리 내에 있는 적 중 가장 가까운 적을 공격합니다. 만약 가장 가까운 적이 여러 명이라면, 가장 왼쪽에 있는 적을 공격합니다. 모든 궁수의 공격이 끝나면, 화살을 맞은 적들은 사라지고, 남은 적들은 한 칸 아래로 이동합니다. `N`번 행을 넘어가면 적은 게임에서 제외됩니다. 목표는 궁수 3명을 배치하여 제거할 수 있는 적의 최대 수를 찾는 것입니다.

주어진 코드의 풀이 전략은 다음과 같습니다.

1.  **궁수 배치 (조합): `dfs(int count, int start, int[] archers)`**
    *   `M`개의 열 중 3개의 궁수 위치를 선택해야 합니다. `M`의 크기가 최대 15로 작기 때문에, `C(M, 3)`의 조합을 완전 탐색으로 구할 수 있습니다.
    *   `dfs` 함수는 재귀적으로 `start` 인덱스부터 `M`까지 반복하며 3개의 궁수 위치(열 인덱스)를 `archers` 배열에 저장합니다. `isVisited` 배열은 중복된 열을 선택하지 않도록 돕습니다.
    *   3개의 궁수 위치가 결정되면 (`count == 3`), 해당 조합으로 `bfs` 시뮬레이션을 시작합니다.

2.  **게임 시뮬레이션 (`bfs(int[] archers)`)**
    *   각 궁수 조합에 대해 게임을 처음부터 다시 시뮬레이션해야 하므로, 초기 맵 `grid`를 `map` 배열에 `clone()`하여 복사합니다.
    *   `while (true)` 루프를 통해 적이 모두 사라지거나 게임판 밖으로 이동할 때까지 턴을 반복합니다.
    *   **공격 단계:**
        *   `boolean[][] targets` 배열을 사용하여 이번 턴에 공격받을 적의 위치를 표시합니다. 여러 궁수가 같은 적을 공격할 수 있으므로, `targets` 배열을 통해 중복 제거 및 정확한 킬 카운트를 관리합니다.
        *   각 궁수마다 `findTarget()` 함수를 호출하여 가장 가까운 적을 찾습니다.
        *   `findTarget()`이 반환한 적이 있다면 `targets` 배열에 표시합니다.
        *   모든 궁수의 공격 대상이 정해지면, `targets` 배열에 표시된 모든 적을 `map`에서 제거(`map[i][j] = 0`)하고 `killCount`를 증가시킵니다.
    *   **적 이동 단계:**
        *   `moveEnemies()` 함수를 호출하여 모든 적을 한 칸 아래로 이동시킵니다. 가장 아랫줄에 있던 적은 맵 밖으로, 가장 윗줄은 비어있는 상태가 됩니다.
    *   현재 `killCount`를 `MAX_KILL_COUNT`와 비교하여 최댓값을 갱신합니다.

3.  **타겟 찾기 (BFS 탐색): `findTarget(int archerCol)`**
    *   각 궁수의 위치(`N-1` 행, `archerCol` 열)에서 시작하는 BFS 탐색을 수행합니다.
    *   큐에는 `[row, col, distance]` 정보를 저장합니다.
    *   `visited` 배열을 사용하여 이미 방문한 칸은 다시 방문하지 않도록 합니다.
    *   BFS의 핵심은 탐색 순서입니다. 문제에서 요구하는 "가장 가까운, 그 중 가장 왼쪽"이라는 우선순위를 지키기 위해, `dx`, `dy` 배열은 `(0, -1)` (왼쪽), `(-1, 0)` (위쪽), `(0, 1)` (오른쪽) 순서로 탐색하도록 정의되어 있습니다.
        *   BFS는 기본적으로 `distance`를 기준으로 탐색하기 때문에 "가장 가까운" 조건은 자연스럽게 만족됩니다.
        *   동일 거리에 있는 적들 중 "가장 왼쪽"을 먼저 찾기 위해, 이웃 노드를 탐색할 때 왼쪽, 위, 오른쪽 순서로 탐색합니다. 가장 먼저 큐에서 꺼내지는 (즉, 가장 먼저 발견되는) 적이 곧 "가장 가까우면서 가장 왼쪽"에 있는 적이 됩니다.
    *   현재 탐색 거리가 `D`를 초과하면 더 이상 탐색하지 않습니다.
    *   적(`map[r][c] == 1`)을 발견하면 즉시 해당 적의 위치를 반환합니다.

### 2. 시간 복잡도와 공간 복잡도 분석

문제의 제약 조건은 `N, M <= 15`, `D <= 10`으로 매우 작습니다. 따라서 완전 탐색과 시뮬레이션이 충분히 허용됩니다.

*   **N**: 격자판 행의 수 (1 ~ 15)
*   **M**: 격자판 열의 수 (3 ~ 15)
*   **D**: 궁수 공격 거리 제한 (1 ~ 10)

**시간 복잡도:**

1.  **궁수 배치 (`dfs`)**:
    *   `M`개의 열 중 3개를 선택하는 조합의 수: `C(M, 3)`.
    *   최대 `C(15, 3) = (15 * 14 * 13) / (3 * 2 * 1) = 455`가지 경우.

2.  **시뮬레이션 (`bfs`) (각 궁수 조합마다)**:
    *   `while (true)` 루프: 최대 `N`번 (적이 `N`칸 이동하면 모두 사라짐).
    *   각 턴마다:
        *   `findTarget()` (BFS): 3명의 궁수 각각 BFS 탐색을 수행합니다. 최악의 경우, `D` 거리 내의 모든 칸을 탐색합니다. 이는 `O(D^2)` 또는 최대 `O(N*M)` (만약 `D`가 충분히 커서 모든 맵을 탐색할 수 있다면)에 해당합니다. `D=10`일 때 대략 100칸 정도, `N*M = 15*15 = 225`칸 정도이므로 `O(D^2)` 또는 `O(N*M)`으로 볼 수 있습니다.
        *   `targets` 배열 처리: `O(N*M)`.
        *   `moveEnemies()`: `N`개의 배열을 복사하므로 `O(N*M)`.
        *   `hasEnemy()`: 맵 전체를 스캔하므로 `O(N*M)`.
    *   따라서 한 번의 시뮬레이션에 드는 시간은 대략 `N * (3 * O(N*M) + O(N*M) + O(N*M) + O(N*M))` = `O(N * N*M)` = `O(N^2 * M)`.
    *   최대값으로 계산: `15 * (3 * (15*15) + (15*15) + (15*15) + (15*15))` = `15 * (4 * 225) = 15 * 900 = 13500`.

3.  **총 시간 복잡도**: `C(M, 3) * O(N^2 * M)`
    *   `455 * 13500` = 약 `6 * 10^6` (6백만) 연산.
    *   이는 1초 내에 충분히 실행 가능한 매우 효율적인 복잡도입니다.

**공간 복잡도:**

*   `grid`, `map`: 각각 `O(N*M)`. (e.g., `15 * 15` int 배열)
*   `isVisited` (for `dfs`): `O(M)`.
*   `archers` 배열: `O(1)` (항상 3개의 정수).
*   `dfs` 재귀 스택: `O(M)` (재귀 깊이 최대 3).
*   `findTarget` 내 `Queue`와 `visited` 배열: `O(N*M)`.
*   `targets` 배열: `O(N*M)`.

총 공간 복잡도는 `O(N*M)`이며, `15 * 15` 크기이므로 매우 작고 효율적입니다.

### 3. 코드에서 개선할 점 및 주의해야 할 예외 케이스 (Edge Case)

주어진 코드는 매우 깔끔하고 효율적으로 작성되어 있어, 큰 개선점은 없어 보입니다. 하지만 몇 가지 측면에서 더 고민해볼 수 있습니다.

1.  **`hasEnemy()` 최적화**:
    *   현재 `hasEnemy()` 함수는 매 턴 `O(N*M)` 시간을 들여 맵 전체를 스캔합니다.
    *   이를 개선하려면, `map`에 존재하는 적의 총 개수를 저장하는 `enemyCount` 변수를 도입할 수 있습니다.
    *   초기 맵을 복사할 때 `enemyCount`를 계산하고, 적이 죽거나 맵 밖으로 이동할 때마다 이 변수를 업데이트하면 `hasEnemy()` 호출을 `O(1)`로 줄일 수 있습니다. (물론 각 시뮬레이션 시작 시 `enemyCount`를 초기화해야 합니다.)
    *   하지만 현재 `N, M` 제약조건에서는 `O(N*M)` 스캔도 충분히 빠르므로 필수는 아닙니다.

2.  **`moveEnemies()` 배열 복사 방식**:
    *   `map[i] = map[i - 1].clone();` 방식을 사용하고 있습니다. 이는 새로운 배열 객체를 생성하고 내용을 복사하는 방식입니다. `int[]` 같은 기본형 배열의 경우 `.clone()`이 일반적으로 효율적입니다.
    *   만약 객체 배열이라면 `clone()`은 얕은 복사(shallow copy)가 되므로 주의해야 하지만, 여기서는 `int` 배열이라 문제없습니다.
    *   더 나아가 `map` 배열 자체를 `N+1` 크기로 만들고, 실제 데이터를 인덱싱하는 `offset` 변수를 관리하여 원형 큐처럼 사용하는 기법도 있습니다. 이 경우 물리적인 복사 없이 논리적인 이동이 가능하지만, 코드가 복잡해질 수 있습니다. 현재 코드의 `clone()` 방식은 직관적이고 성능상 문제없습니다.

3.  **예외 케이스 (Edge Cases)**:
    *   **초기 맵에 적이 전혀 없는 경우:** `hasEnemy()`가 바로 `false`를 반환하여 `killCount`가 0이 되고, `MAX_KILL_COUNT`도 0으로 올바르게 처리됩니다.
    *   **모든 적이 `D` 거리 밖에 있는 경우:** `findTarget()`이 `null`을 반환하고, `targets` 배열에 아무것도 추가되지 않아 `turnKill`이 0이 됩니다. 올바르게 처리됩니다.
    *   **여러 궁수가 같은 적을 공격하는 경우:** `boolean[][] targets` 배열 덕분에 해당 적은 한 번만 죽은 것으로 처리되고 `killCount`도 한 번만 증가합니다. 매우 중요한 부분이며, 잘 처리되었습니다.
    *   **`M < 3`인 경우 (문제 제약에 따르면 발생하지 않지만):** `dfs` 함수가 `count == 3`에 도달하지 못해 `bfs`가 호출되지 않고 `MAX_KILL_COUNT`는 초기값 0을 유지하게 됩니다. 이 또한 논리적으로는 맞습니다.
    *   **궁수 위치가 중복될 수 있는가?**: `dfs`에서 `isVisited` 배열과 `start + 1`을 사용하여 각 궁수가 다른 열에 배치되도록 강제합니다. 이는 문제의 의도에 부합합니다.

### 결론

"캐슬 디펜스" 문제는 조합을 통한 완전 탐색과 BFS를 활용한 시뮬레이션의 전형적인 예시입니다. 주어진 Java 코드는 문제의 요구사항을 정확히 이해하고, 효율적인 탐색(BFS의 우선순위 처리)과 시뮬레이션 로직(맵 복사, 적 이동, 타겟 중복 처리)을 훌륭하게 구현했습니다. `N, M, D`의 작은 제약 조건 덕분에 완벽한 탐색이 가능하며, 코드의 구조 또한 매우 명확하고 이해하기 쉽습니다.

이런 유형의 문제는 단순히 알고리즘을 아는 것을 넘어, 문제의 조건을 꼼꼼히 해석하고, 이를 코드로 어떻게 효율적으로 구현할지 계획하는 능력을 요구합니다. 특히 BFS에서 탐색 순서를 통해 추가 조건을 만족시키는 부분이 인상 깊었습니다. 다음 코딩 테스트에서도 이처럼 깔끔하고 효율적인 풀이를 만드시길 바랍니다!

---