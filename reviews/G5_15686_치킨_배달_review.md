---
title: "[리뷰] G5_15686_치킨_배달.java"
date: 2026-02-02
tags: [Algorithm, Java]
---

안녕하세요, 알고리즘 전문가이자 기술 블로거! 오늘 함께 분석해볼 코딩 테스트 문제는 바로 백준 15686번, **"치킨 배달"** 문제입니다. 이 문제는 전형적인 조합(Combination) 문제로, 깊이 우선 탐색(DFS)과 백트래킹을 활용하여 최적의 해를 찾아내는 문제입니다.

제공해주신 Java 코드를 바탕으로 문제 풀이 전략, 시간/공간 복잡도 분석, 그리고 개선점과 예외 케이스까지 자세히 살펴보겠습니다.

---

## [백준 15686] 치킨 배달 (Java) - DFS/백트래킹으로 최적의 치킨집 찾기

### 1. 문제 요약 및 풀이 전략

**문제 요약:**
N x N 크기의 도시가 주어집니다. 도시에는 빈 칸(0), 집(1), 치킨집(2)이 존재합니다. 우리는 이 도시에서 최대 M개의 치킨집만을 남기고 나머지는 폐업시켜야 합니다. 목표는 폐업시키지 않고 남은 치킨집들로부터 각 집까지의 "치킨 거리"를 계산하고, 이 모든 "치킨 거리"의 합인 "도시의 치킨 거리"를 최소화하는 것입니다. 한 집의 치킨 거리는 가장 가까운 치킨집까지의 맨해튼 거리(`|r1-r2| + |c1-c2|`)를 의미합니다.

**풀이 전략:**
이 문제는 모든 치킨집 중에서 M개를 선택하는 **조합(Combination)** 문제입니다. 총 치킨집의 개수가 최대 13개로 제한되어 있기 때문에, 모든 가능한 조합을 탐색하는 완전 탐색(Brute Force) 방식의 DFS(Depth-First Search)와 백트래킹을 적용할 수 있습니다.

제공된 코드의 전략은 다음과 같습니다.

1.  **치킨집 선택 (DFS 백트래킹):**
    *   총 `chicken`개의 치킨집 중 `M`개를 남겨야 하므로, `chicken - M`개의 치킨집을 **폐업시키는 경우의 수**를 탐색합니다.
    *   `dfs(startR, startC, count)` 함수는 `count`개의 치킨집을 폐업시킬 때 호출됩니다. `startR`, `startC`는 중복 탐색을 방지하고 조합을 만들기 위한 인덱스입니다.
    *   현재 위치(`startR`, `startC`부터)부터 `N*N` 격자를 순회하며 치킨집(값이 2인 칸)을 발견합니다.
    *   해당 치킨집을 `grid[i][j] = 0`으로 변경하여 **'폐업' 상태**로 만들고, `count - 1`로 재귀 호출합니다.
    *   재귀 호출에서 돌아오면 `grid[i][j] = 2`로 **원래 상태로 복구 (백트래킹)** 하여 다음 경우의 수를 탐색할 수 있도록 합니다.

2.  **도시의 치킨 거리 계산 (`count == 0`인 경우):**
    *   `count`가 0이 되면, 정확히 `M`개의 치킨집만 남은 상태(또는 총 치킨집 수가 M개 이하인 경우 모든 치킨집이 남은 상태)가 됩니다.
    *   `langeCnt`라는 `N x N` 크기의 배열을 새로 초기화하고, `Integer.MAX_VALUE`로 채웁니다. 이 배열은 각 집의 최소 치킨 거리를 저장할 것입니다.
    *   현재 `grid`에 남아있는 모든 치킨집(`grid[i][j] == 2`)을 순회합니다.
    *   각 치킨집에 대해 `langeChecker` 함수를 호출하여 모든 집(`grid[i][j] == 1`)과의 맨해튼 거리를 계산하고, `langeCnt` 배열에 저장된 값과 비교하여 최소값을 갱신합니다.
    *   모든 치킨집에 대한 거리 계산이 완료되면, `langeCnt` 배열을 다시 순회하며 모든 집(`grid[i][j] == 1`)의 치킨 거리를 합산합니다.
    *   합산된 `sum`을 전역 변수 `answer`와 비교하여 최소값을 갱신합니다.

이러한 전략은 모든 M개 치킨집 조합에 대해 "도시의 치킨 거리"를 계산하고 최소값을 찾아냅니다.

---

### 2. 시간 복잡도와 공간 복잡도 분석

**주요 제약사항:**
*   `N` (도시 크기): 1 이상 50 이하
*   `M` (남길 치킨집 수): 1 이상 총 치킨집 수 이하
*   총 치킨집 수: 1 이상 13 이하 (문제 조건에 따라)

**시간 복잡도:**

1.  **조합 생성 (DFS 부분):**
    *   총 `C`개의 치킨집 중 `M`개를 남기는 경우의 수는 `C_C_M` (C choose M) 또는 `C_C_(C-M)` 입니다.
    *   최악의 경우, `C=13`일 때 `13C(13/2)` (즉 `13C6` 또는 `13C7`)이 최대가 되며, 이는 `13! / (6! * 7!) = 1716`가지 경우의 수입니다.
    *   DFS 재귀 호출 내부에서 `N*N` 격자를 순회하며 다음 치킨집을 찾지만, 이 순회는 조합 생성을 위한 것이므로 각 `C_C_M` 경우를 만드는 데 드는 비용으로 간주할 수 있습니다.

2.  **치킨 거리 계산 (`count == 0` 베이스 케이스):**
    *   `langeCnt` 배열 초기화: `O(N^2)`
    *   남아있는 치킨집 찾기: `O(N^2)` (최대 M개)
    *   `langeChecker` 함수:
        *   이 함수는 남아있는 **각 치킨집**에 대해 모든 집(`grid[i][j] == 1`)과의 거리를 계산합니다.
        *   `langeChecker` 내부의 이중 루프는 `O(N^2)`입니다.
        *   최대 `M`개의 치킨집에 대해 `langeChecker`가 호출되므로, 이 단계의 총 비용은 `O(M * N^2)`입니다.
    *   최종 `sum` 계산: `O(N^2)`

3.  **총 시간 복잡도:**
    *   `O(조합의 수 * 각 조합별 계산 비용)`
    *   `O(C_C_M * M * N^2)`
    *   최악의 경우: `13C6 * 13 * 50^2`
    *   `1716 * 13 * 2500` ≈ `5.5 * 10^7` (5천 5백만)
    *   일반적으로 1초에 약 1억 번의 연산이 가능하다고 볼 때, 이 정도 연산량은 제한 시간(보통 1초) 내에 충분히 통과할 수 있습니다.

**공간 복잡도:**

1.  `grid` 배열: `O(N^2)`
2.  `langeCnt` 배열: `O(N^2)` (DFS의 베이스 케이스에서 매번 생성되지만, 스택 프레임과는 별개로 전체 공간에 영향을 미칩니다.)
3.  DFS 재귀 스택: 최대 `C - M` (제거할 치킨집 수) 또는 `C` (총 치킨집 수) 깊이까지 쌓일 수 있습니다. `O(C)`
    *   `N=50`일 때 `N^2 = 2500` int 배열은 약 `2500 * 4 bytes = 10KB`로 매우 작습니다.

따라서, 전체 공간 복잡도는 `O(N^2)`입니다.

---

### 3. 코드에서 개선할 점이나 주의해야 할 예외 케이스 (Edge Case)

**개선할 점:**

1.  **치킨집 좌표 관리 최적화:**
    *   현재 코드는 `grid` 배열 자체를 변경(`grid[i][j] = 0;`)하며 백트래킹을 수행합니다. 이는 간단한 방법이지만, DFS 탐색 과정에서 매번 `N*N` 격자를 순회하며 치킨집(값 2)을 찾아야 합니다.
    *   대신, `main` 함수에서 모든 치킨집의 좌표를 `ArrayList<Point>`와 같은 자료구조에 미리 저장해두면 더 효율적입니다.
    *   `dfs` 함수에서는 이 `ArrayList`의 인덱스를 기준으로 치킨집을 선택/제거(예: `boolean isSelected[]` 배열 사용)하고 재귀 호출을 수행할 수 있습니다. 이렇게 하면 `N*N` 격자를 불필요하게 순회하는 오버헤드를 줄일 수 있습니다.
    *   `dfs(int currentChickenIdx, int countToRemove)` 형태로 변경하고, `currentChickenIdx`부터 `ArrayList`를 탐색하는 방식이 조합 구현에 더 일반적입니다.

2.  **`langeChecker` 호출 및 `langeCnt` 초기화:**
    *   `langeCnt` 배열을 `dfs`의 베이스 케이스에 진입할 때마다 `new int[N][N]`으로 생성하고 `Arrays.fill`로 `MAX_VALUE`를 채우는 것은 `O(N^2)` 비용이 발생합니다. 이것은 각 조합마다 필연적으로 수행해야 하는 계산이므로 큰 문제는 아니지만, 만약 `langeChecker`를 더 일찍 호출하거나 `langeCnt`를 더 효율적으로 관리할 수 있는 구조라면 미세한 개선의 여지는 있습니다. (하지만 현재 구조에서는 이 방식이 가장 명확합니다.)

3.  **객체 지향적 접근 (선택 사항):**
    *   경쟁 프로그래밍에서는 `static` 변수와 간결한 함수들이 선호되지만, 실제 프로젝트에서는 `Point` 또는 `Location` 클래스를 정의하여 좌표를 캡슐화하고, `getDistance`와 같은 유틸리티 메서드를 포함하면 코드 가독성과 재사용성이 높아질 것입니다.

**주의해야 할 예외 케이스 (Edge Case):**

1.  **치킨집이 M개보다 적거나 같은 경우:**
    *   문제에서 "최대 M개의 치킨집을 고른다"고 했으므로, 만약 도시 내의 총 치킨집 개수가 `M`개보다 적거나 같다면, 모든 치킨집을 유지하는 것이 정답입니다.
    *   현재 코드는 `dfs(0, 0, chicken - M)`으로 시작합니다.
    *   만약 `chicken <= M`이라면 `chicken - M`은 0 또는 음수가 됩니다.
        *   `chicken - M == 0`인 경우: `dfs(..., 0)` 호출 즉시 베이스 케이스로 진입하여 모든 치킨집으로 계산합니다. 문제없습니다.
        *   `chicken - M < 0`인 경우 (예: `chicken=3, M=5` -> `count=-2`): `count < 0`인 상태로 재귀 호출이 계속됩니다. `count`가 0이 아닌 이상 루프를 돌지만, `grid[i][j] == 2`를 발견해도 `count`가 음수이므로 `count - 1`은 계속 음수로 줄어들기만 합니다. 결국 모든 치킨집을 방문해도 `count`가 0이 되지 않아 베이스 케이스에 도달하지 못하고 `answer`는 `Integer.MAX_VALUE`로 남을 수 있습니다. 이 경우 초기 `dfs` 호출 전에 `if (chicken <= M)` 조건을 추가하여 모든 치킨집으로 바로 계산하거나, `dfs` 시작 시 `count`가 음수일 경우 예외 처리를 해주는 것이 안전합니다.
        *   **해결책:** `main` 함수에서 `if (chicken <= M)`일 경우, `dfs`를 호출하기 전에 `grid`에 있는 모든 치킨집으로 `langeCnt`를 계산하고 바로 `answer`를 갱신하는 로직을 추가하는 것이 더 명확하고 안전합니다.
            ```java
            if (chicken <= M) { // 모든 치킨집을 유지해야 하는 경우
                int[][] langeCnt = new int[N][N];
                for (int i = 0; i < N; i++) {
                    Arrays.fill(langeCnt[i], Integer.MAX_VALUE);
                }
                for (int i = 0; i < N; i++) {
                    for (int j = 0; j < N; j++) {
                        if (grid[i][j] == 2) {
                            langeChecker(langeCnt, new int[]{i, j});
                        }
                    }
                }
                int sum = 0;
                for (int i = 0; i < N; i++) {
                    for (int j = 0; j < N; j++) {
                        if (grid[i][j] == 1) {
                            sum += langeCnt[i][j];
                        }
                    }
                }
                answer = sum; // 이 경우가 최소이므로 바로 할당
            } else { // M개를 초과하는 치킨집이 있을 경우
                dfs(0, 0, chicken - M);
            }
            ```

2.  **도시에 집이 없는 경우 (`grid`에 1이 없는 경우):**
    *   이 경우, 모든 집의 치킨 거리 합은 0이 됩니다. 코드는 `sum`을 0으로 계산하고 `answer`를 0으로 올바르게 갱신할 것입니다. 문제없습니다.

3.  **도시에 치킨집이 없는 경우 (`grid`에 2가 없는 경우):**
    *   `chicken` 변수가 0이 됩니다. 위에서 언급한 대로 `dfs(0, 0, -M)`이 호출될 것이고, `count`가 음수가 되어 베이스 케이스에 도달하지 못할 수 있습니다.
    *   **해결책:** 치킨집이 없는 경우, 도시의 치킨 거리는 무한대이거나 정의되지 않을 수 있습니다. 문제의 제약사항에 따라 치킨집이 항상 하나 이상 존재한다고 가정할 수도 있지만, 그렇지 않다면 `chicken == 0`일 때 적절한 처리를 해야 합니다. 예를 들어 `answer`를 `Integer.MAX_VALUE` 그대로 두거나, 문제 조건에 따라 `-1` 등을 출력할 수 있습니다. (대부분의 코딩 테스트 문제에서는 최소한의 구성 요소가 존재한다고 가정합니다.)

4.  **`startR`, `startC`를 이용한 조합 탐색 로직:**
    *   `for (int j = (i == startR ? startC : 0); j < N; j++)` 이 부분은 행이 `startR`과 같을 때는 `startC`부터 시작하고, 다음 행부터는 0부터 시작하도록 하여 중복 없이 조합을 만드는 핵심 로직입니다. 이는 정확하게 구현되었습니다.

---

### 결론

제공해주신 코드는 백트래킹을 이용한 조합 문제의 풀이법을 잘 구현하고 있습니다. 특히 `grid` 배열을 직접 변경하고 복구하는 방식은 추가적인 자료구조 없이 상태를 관리하는 간결한 방법입니다. 시간/공간 복잡도 측면에서도 주어진 제약사항 내에서 효율적으로 동작합니다.

몇 가지 예외 케이스 처리(특히 `chicken <= M`일 때의 `count` 값)와 치킨집 좌표 관리의 효율성을 개선한다면 더욱 견고하고 최적화된 코드가 될 것입니다. 알고리즘 문제 해결 능력을 한층 더 끌어올리는 좋은 연습이 될 것입니다!

해당 포스팅이 문제 이해와 코드 개선에 도움이 되셨기를 바랍니다. Happy Coding!