---
title: "[리뷰] S2_2961_도영이가_만든_맛있는_음식.java"
date: 2026-02-09
tags: [Algorithm, Java]
---

안녕하세요, 알고리즘과 자료구조의 세계를 탐험하는 여러분!
오늘은 백준 온라인 저지에서 "도영이가 만든 맛있는 음식 (2961번)" 문제를 함께 분석해보고, Java로 구현된 풀이를 통해 깊이 우선 탐색(DFS)의 묘미를 느껴보는 시간을 갖겠습니다. 이 문제는 DFS를 활용한 부분집합 생성의 전형적인 예시로, 재귀 호출의 아름다움을 잘 보여줍니다.

---

## 🍽️ [백준 2961] 도영이가 만든 맛있는 음식 - DFS로 부분집합 생성하기

### 1. 문제 요약 및 풀이 전략

**문제 설명:**
`N`개의 재료가 주어지며, 각 재료는 고유한 '신맛'과 '쓴맛'을 가지고 있습니다. 도영이는 이 재료들 중 몇 개를 골라 음식을 만들려고 합니다. 음식의 신맛은 고른 재료들의 신맛을 **모두 곱한 값**이고, 쓴맛은 고른 재료들의 쓴맛을 **모두 더한 값**입니다. 이때, 음식의 신맛과 쓴맛의 차이가 가장 작게 되는 경우를 찾아 그 최솟값을 출력해야 합니다. 단, 재료는 **적어도 하나 이상** 선택해야 합니다.

**핵심 아이디어 및 풀이 전략:**
이 문제는 `N`개의 재료 각각에 대해 '이 재료를 선택할 것인가?' 또는 '선택하지 않을 것인가?' 두 가지 선택지가 존재합니다. `N`이 최대 10으로 매우 작다는 점을 고려할 때, 모든 가능한 재료 조합(부분집합)을 탐색하여 최솟값을 찾는 완전 탐색(Brute Force) 방식이 가능합니다.

이러한 "선택/미선택" 패턴의 모든 경우의 수를 탐색하는 데에는 **깊이 우선 탐색(DFS)** 또는 백트래킹이 가장 적합합니다.

**DFS 설계:**
DFS 함수는 다음과 같은 인자들을 가질 수 있습니다:
*   `count`: 현재 고려 중인 재료의 인덱스 (0부터 N-1까지).
*   `currSourScore`: 현재까지 선택된 재료들의 신맛을 모두 곱한 값. (주의: 곱셈의 항등원인 `1`로 초기화해야 합니다.)
*   `currBitterScore`: 현재까지 선택된 재료들의 쓴맛을 모두 더한 값. (주의: 덧셈의 항등원인 `0`으로 초기화해야 합니다.)
*   `selectCount`: 현재까지 선택된 재료의 개수. (최소 한 개 선택 조건을 처리하기 위함입니다.)

1.  **기저 조건 (Base Case):**
    `count == N` (모든 재료를 다 고려했을 때).
    *   이때, `selectCount`가 0보다 큰지 확인하여 **적어도 하나 이상의 재료를 선택했다면**, 현재 `currSourScore`와 `currBitterScore`의 차이(`Math.abs(currSourScore - currBitterScore)`)를 계산하여 전역 변수 `minDiff`와 비교하여 최솟값을 갱신합니다.

2.  **재귀 호출 (Recursive Steps):**
    현재 `count`번째 재료에 대해 두 가지 선택을 합니다.
    *   **현재 재료를 선택하는 경우:**
        `dfs(count + 1, currSourScore * sArr[count], currBitterScore + bArr[count], selectCount + 1)`
    *   **현재 재료를 선택하지 않는 경우:**
        `dfs(count + 1, currSourScore, currBitterScore, selectCount)`

**초기 호출:**
`dfs(0, 1, 0, 0)`로 DFS를 시작합니다. (0번째 재료부터 시작, 신맛 초기값 1, 쓴맛 초기값 0, 선택된 재료 수 0)

### 2. 시간 복잡도와 공간 복잡도 분석

*   **시간 복잡도 (Time Complexity):**
    각 재료마다 '선택한다'와 '선택하지 않는다'의 2가지 경우의 수가 있습니다. `N`개의 재료가 있으므로 총 `2^N`가지의 부분집합(조합)이 생성됩니다. 각 부분집합에 대해 신맛과 쓴맛을 계산하고 차이를 비교하는 연산은 상수 시간에 이루어집니다.
    따라서, 시간 복잡도는 **O(2^N)** 입니다.
    문제에서 `N`은 최대 10이므로 `2^10 = 1024`가지의 경우만을 탐색하게 됩니다. 이는 현대 컴퓨터에서 매우 빠르게 수행될 수 있는 연산량입니다. (일반적으로 1초에 약 10^8 연산을 허용합니다.)

*   **공간 복잡도 (Space Complexity):**
    *   재귀 호출 스택: DFS의 깊이는 최대 `N`이므로, 재귀 스택 공간으로 **O(N)**이 필요합니다.
    *   입력 배열 (`sArr`, `bArr`): `N`개의 재료 정보를 저장하는 데 **O(N)** 공간이 필요합니다.
    *   전역 변수: `minDiff`, `N` 등은 상수 공간 **O(1)**을 사용합니다.
    따라서, 전체 공간 복잡도는 **O(N)** 입니다.

### 3. 코드에서 개선할 점 및 주의사항 (Edge Case)

제시된 코드는 DFS를 이용한 부분집합 생성을 매우 잘 구현하고 있습니다. 특히 다음과 같은 점들은 칭찬할 만합니다:

*   **정확한 초기값 설정:** 신맛 계산을 위한 `currSourScore`를 `1`로, 쓴맛 계산을 위한 `currBitterScore`를 `0`으로 초기화한 점은 곱셈과 덧셈의 항등원을 올바르게 적용한 것입니다.
*   **"최소 한 개 선택" 조건 처리:** `selectCount` 변수를 활용하여 `count == N`인 기저 조건에서 `selectCount > 0`을 확인하는 부분은 문제의 중요한 제약을 정확하게 반영했습니다.
*   **빠른 입출력:** `BufferedReader`와 `StringTokenizer`를 사용하여 대량의 입력을 효율적으로 처리했습니다.

하지만 몇 가지 개선할 점과 주의해야 할 예외 케이스(Edge Case)가 있습니다.

1.  **자료형(`long`) 사용의 필요성 (가장 중요!):**
    문제의 제약 조건을 다시 살펴보면, 각 재료의 신맛과 쓴맛은 1부터 1,000,000,000 (10^9)까지 가능하다고 명시되어 있습니다.
    *   **쓴맛:** `N`이 10이고 모든 쓴맛이 `10^9`라면, 총 쓴맛은 `10 * 10^9 = 10^10`이 됩니다. 이는 `int`의 최대값(`약 2 * 10^9`)을 훨씬 초과하므로 `long` 타입을 사용해야 합니다.
    *   **신맛:** `N`이 10이고 모든 신맛이 `10^9`라면, 총 신맛은 `(10^9)^10 = 10^90`이 됩니다. 이 값은 `long`의 최대값(`약 9 * 10^18`)마저 아득히 초과합니다. 다만, 대부분의 코딩 테스트 문제에서는 이렇게 엄청난 중간 결과 값이 나오는 경우 최종 결과는 특정 modulo로 나누거나, 실제 테스트 케이스에서는 중간 값이 `long` 범위 내에 들어오도록 설계되는 경우가 많습니다. **만약 `long`으로도 감당이 안 되는 값이라면 `BigInteger`를 사용해야 하지만, 이 문제에서는 `long`으로 충분한 경우가 대부분입니다.** (신맛 재료가 모두 100만(10^6)이어도 10개 곱하면 `(10^6)^10 = 10^60`이라 `long`을 초과합니다. 따라서 실제 문제는 `N`이 10이더라도 신맛이 그렇게 크게 나오지 않는 테스트케이스로 구성되었거나, 문제 출제자의 의도는 `long`으로 충분히 커버 가능하다고 생각하는 경우가 많습니다.)
    
    **결론적으로, `currSourScore`, `currBitterScore`는 물론이고, `minDiff` 또한 `long` 타입으로 변경하는 것이 안전하고 정확한 풀이가 됩니다.** 현재 코드에서는 `int`로 선언되어 있어 오버플로우가 발생할 수 있습니다.

    ```java
    // 변경 전:
    // static int minDiff = Integer.MAX_VALUE;
    // ...
    // private static void dfs(int count, int currSourScore, int currBitterScore, int selectCount) {
    // ...

    // 변경 후:
    static long minDiff = Long.MAX_VALUE; // minDiff도 long으로 변경
    // ...
    private static void dfs(int count, long currSourScore, long currBitterScore, int selectCount) { // currSourScore, currBitterScore를 long으로 변경
        if (count == N) {
            if(selectCount > 0) minDiff = Math.min(minDiff, Math.abs(currSourScore - currBitterScore));
            return;
        }

        // 재귀 호출 시에도 인자 타입 변경
        dfs(count + 1, currSourScore * sArr[count], currBitterScore + bArr[count], selectCount + 1); 
        dfs(count + 1, currSourScore, currBitterScore, selectCount);
    }
    ```
    (참고: `sArr`와 `bArr`는 입력 값을 저장하므로 `int` 배열로 두어도 괜찮습니다. 다만, 연산 시 `currSourScore`와 `currBitterScore`가 `long`이므로 연산 결과는 `long`으로 자동 형변환됩니다.)

2.  **전역 변수 사용:**
    경쟁 프로그래밍에서는 코드를 간결하게 만들기 위해 `minDiff`, `sArr`, `bArr`, `N`과 같은 변수들을 `static` 전역 변수로 선언하는 경우가 많습니다. 이는 짧은 시간 내에 코드를 작성해야 할 때 효율적입니다. 하지만 일반적인 소프트웨어 개발에서는 함수의 독립성을 높이고 잠재적인 사이드 이펙트를 줄이기 위해 필요한 값들을 함수의 매개변수로 전달하거나, 객체 지향적으로 설계하여 클래스의 멤버 변수로 관리하는 것이 더 좋은 관행입니다. 이 문제의 규모에서는 큰 문제가 되지 않습니다.

---

이 문제는 DFS를 이용한 완전 탐색의 기초를 다지기에 아주 좋은 문제입니다. 특히 재귀 함수의 인자 설계와 기저 조건 처리를 통해 모든 경우의 수를 효율적으로 탐색하는 방법을 배울 수 있습니다. 자료형의 오버플로우 문제에 주의하면서 코드를 작성한다면 더욱 완벽한 풀이가 될 것입니다.

다음에도 흥미로운 알고리즘 문제와 함께 돌아오겠습니다! 🚀