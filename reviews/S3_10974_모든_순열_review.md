---
title: "[리뷰] S3_10974_모든_순열.java"
date: 2026-02-05
tags: [Algorithm, Java]
---

안녕하세요, 알고리즘과 자료구조의 세계를 탐험하는 여러분! 오늘은 백준 온라인 저지에서 Silver 3 난이도에 해당하는 `10974번: 모든 순열` 문제를 깊이 탐구하고, 주어진 Java 코드 풀이를 분석해보는 시간을 갖겠습니다. 이 문제는 백트래킹(Backtracking) 기법을 이해하는 데 매우 중요한 기본 문제이므로, 함께 차근차근 살펴보시죠!

---

## 백준 S3 10974: 모든 순열 (All Permutations) 깊이 탐색(DFS)으로 정복하기

### 문제 요약 및 풀이 전략

#### 1. 문제 요약
주어진 정수 `N`에 대해, 1부터 `N`까지의 모든 자연수를 한 번씩 사용하여 만들 수 있는 모든 순열을 출력하는 문제입니다. 예를 들어, `N=3`이면 `(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)` 여섯 가지 순열을 출력해야 합니다.

#### 2. 풀이 전략: 백트래킹 (Backtracking)을 이용한 깊이 우선 탐색 (DFS)

순열을 생성하는 가장 전형적인 방법 중 하나는 **백트래킹** 기법을 활용하는 것입니다. 백트래킹은 모든 가능한 경우의 수를 탐색하는 알고리즘으로, 특정 조건을 만족하지 않으면 더 이상 탐색하지 않고 이전 단계로 돌아와(Backtrack) 다른 경우를 시도하는 방식입니다. 이는 깊이 우선 탐색(DFS)과 매우 유사하게 동작합니다.

주어진 코드의 전략은 다음과 같습니다:

1.  **재귀 함수 (DFS) 활용**: `dfs(depth)` 함수는 현재 `depth` (즉, 순열의 `depth`번째 위치)에 숫자를 채우는 역할을 합니다.
2.  **`perm` 배열**: 현재 만들어지고 있는 순열을 저장합니다. `perm[depth]`는 순열의 `depth`번째 요소를 의미합니다.
3.  **`isVisited` 배열**: 각 숫자가 현재 순열에 사용되었는지 여부를 추적합니다. `isVisited[i]`가 `true`이면 `arr[i]` (즉, 숫자 `i+1`)가 이미 사용되었음을 의미합니다.
4.  **`arr` 배열**: 1부터 `N`까지의 숫자를 미리 저장해두는 배열입니다. (사실 이 배열은 필수적이지 않고, 루프에서 `i+1`을 바로 사용해도 무방합니다.)
5.  **베이스 케이스 (Base Case)**: `depth`가 `N`과 같아지면, 하나의 완전한 순열이 완성된 것입니다. 이 순열을 `StringBuilder`에 추가하고 다음 줄로 넘어갑니다.
6.  **재귀 스텝 (Recursive Step)**:
    *   `0`부터 `N-1`까지의 인덱스 `i`에 대해 반복합니다.
    *   만약 `arr[i]`에 해당하는 숫자가 `isVisited[i]`를 통해 아직 사용되지 않았다면,
        *   `isVisited[i] = true`로 표시하여 사용했다고 기록합니다.
        *   `perm[depth] = arr[i]`로 현재 순열의 `depth` 위치에 `arr[i]`를 채웁니다.
        *   `dfs(depth + 1)`을 호출하여 다음 위치의 숫자를 채우러 재귀 호출합니다.
        *   **백트래킹**: 재귀 호출이 끝난 후에는 `isVisited[i] = false`로 되돌려 놓습니다. 이는 `arr[i]`가 다른 순열을 구성할 때 다시 사용될 수 있도록 허용하는 핵심적인 단계입니다.

이러한 과정을 통해 모든 가능한 순열을 중복 없이 효율적으로 탐색할 수 있게 됩니다.

### 시간 복잡도와 공간 복잡도 분석

#### 1. 시간 복잡도 (Time Complexity)
*   **순열의 개수**: `N`개의 서로 다른 원소로 만들 수 있는 순열의 총 개수는 `N!` (N 팩토리얼)입니다.
*   **각 순열 생성 및 출력**: 하나의 순열을 완성하는 데에는 재귀 호출 스택의 깊이가 `N`까지 들어가고, 각 단계에서 `N`번의 반복을 최대 `N`번의 재귀 호출 동안 수행합니다. 또한, 최종적으로 `N`개의 숫자를 `StringBuilder`에 추가하는 과정이 `O(N)` 시간이 걸립니다.
*   따라서, 총 시간 복잡도는 `O(N * N!)`입니다.
    *   `N=8`일 때 `8 * 8! = 8 * 40,320 = 322,560` 연산
    *   `N=10`일 때 `10 * 10! = 10 * 3,628,800 = 36,288,000` 연산
    *   `N=11`일 때 `11 * 11! = 11 * 39,916,800 = 439,084,800` 연산
    `N`이 11 정도만 되어도 4억 회 이상의 연산이 필요하므로, 일반적으로 백트래킹으로 모든 순열을 구하는 문제는 `N`의 크기가 10~12 정도로 제한됩니다.

#### 2. 공간 복잡도 (Space Complexity)
*   **`arr`, `perm`, `isVisited` 배열**: 각각 `N` 크기의 배열이므로 `O(N)` 공간을 사용합니다.
*   **재귀 호출 스택**: `dfs` 함수의 최대 재귀 깊이는 `N`이므로, 스택 공간으로 `O(N)`을 사용합니다.
*   **`StringBuilder sb`**: 모든 순열을 저장하는 데 사용됩니다. 각 순열이 `N`개의 숫자를 가지므로, `N!`개의 순열에 대해 총 `N * N!`에 비례하는 문자열을 저장할 수 있습니다. 예를 들어 `N`개의 숫자를 공백과 함께 저장하면 `(N * 2)` 문자가 필요하므로 대략 `O(N * N!)` 공간을 사용합니다.
*   따라서, 총 공간 복잡도는 `O(N + N!)` 또는 정확하게는 `O(N * N!)`입니다. (출력 버퍼 `sb`를 제외한 보조 공간은 `O(N)`입니다.)

### 코드에서 개선할 점이나 주의해야 할 예외 케이스 (Edge Case)

#### 1. 코드 가독성 및 효율성
*   **명확하고 표준적인 백트래킹 구현**: 주어진 코드는 순열 생성을 위한 백트래킹의 정석적인 구현으로, 매우 깔끔하고 이해하기 쉽습니다. 변수명(`arr`, `perm`, `isVisited`, `depth`)도 직관적입니다.
*   **`StringBuilder` 사용**: 대량의 출력을 `System.out.println`으로 여러 번 수행하는 대신, `StringBuilder`에 모아서 한 번에 출력하는 방식은 입출력 성능 면에서 매우 효율적입니다. 이 점은 경쟁 프로그래밍에서 중요하게 평가됩니다.
*   **`arr` 배열의 사용**: 현재 코드는 `arr` 배열을 미리 1부터 `N`까지 채워두고, `perm[depth] = arr[i]` 와 같이 사용합니다. 이 방법도 유효하지만, `arr` 배열 없이 `for (int i = 1; i <= N; i++)` 와 같이 직접 숫자를 반복하면서 `isVisited` 배열을 숫자 값(1-N)에 맞춰 사용하는 방법도 있습니다. (이 경우 `isVisited` 배열의 크기를 `N+1`로 만들고 `isVisited[i]`로 접근) 현재 코드는 인덱스 `0`부터 `N-1`까지를 통일성 있게 사용한다는 장점이 있습니다.

#### 2. 예외 케이스 (Edge Cases)
*   **`N = 1`**:
    *   `arr = {1}`, `perm = {0}`, `isVisited = {false}`로 초기화됩니다.
    *   `dfs(0)` 호출:
        *   `i=0`일 때, `isVisited[0]`은 `false`이므로 진입.
        *   `isVisited[0] = true`, `perm[0] = arr[0] (즉, 1)`로 설정.
        *   `dfs(1)` 호출:
            *   `depth (1)`이 `N (1)`과 같으므로 베이스 케이스 도달.
            *   `perm` 배열의 `(1)`을 `sb`에 추가 (`1 `).
            *   `sb.append('\n')`.
        *   `dfs(1)` 리턴 후, `isVisited[0] = false` (백트래킹).
    *   정상적으로 `1 \n`이 출력됩니다.
*   **`N`의 최대값 제한**: 앞서 언급했듯이, 이 백트래킹 방식은 `N`의 크기가 약 11~12를 넘어가면 시간 제한에 걸릴 가능성이 매우 높습니다. 문제에서 `N`의 범위가 주어지지 않았지만, 대부분의 "모든 순열" 문제는 `N <= 10` 정도로 주어집니다. 만약 `N`이 훨씬 크다면 다른 종류의 순열 문제 (e.g., 특정 조건을 만족하는 순열만 찾기, k번째 순열 찾기 등)일 가능성이 높으며, 다른 알고리즘(예: 수학적 계산, `next_permutation` 같은 라이브러리 함수)을 고려해야 합니다.

---

### 결론

백준 `S3 10974: 모든 순열` 문제는 백트래킹 기법을 배우고 연습하기에 아주 좋은 기본 문제입니다. 주어진 Java 코드는 이 백트래킹 알고리즘을 모범적으로 구현하고 있으며, `StringBuilder`를 사용하여 효율적인 입출력을 처리하는 점 또한 훌륭합니다.

이 문제를 통해 순열 생성의 원리, 재귀 호출의 깊이, 그리고 `isVisited` 배열을 활용한 상태 관리 및 백트래킹의 중요성을 확실히 이해하셨기를 바랍니다. 여러분의 알고리즘 학습에 큰 도움이 되었기를 바라며, 다음 포스팅에서 또 다른 흥미로운 문제로 찾아뵙겠습니다!

---