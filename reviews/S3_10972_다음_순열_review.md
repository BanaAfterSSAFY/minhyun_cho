---
title: "[리뷰] S3_10972_다음_순열.java"
date: 2026-02-09
tags: [Algorithm, Java]
---

안녕하세요, 알고리즘과 자료구조의 세계를 탐험하는 여러분! 오늘은 백준 온라인 저지 10972번, "다음 순열" 문제 풀이를 함께 분석해보겠습니다. 순열 문제는 다양한 형태로 출제되며, 특히 "다음 순열"을 효율적으로 찾는 방법은 알아두면 유용한 알고리즘 패턴입니다.

---

## [백준 10972] 다음 순열 - Java 완전 정복!

### 1. 문제 요약 및 풀이 전략

**문제 요약:**
정수로 이루어진 수열이 주어졌을 때, 해당 수열의 사전순(lexicographical order)으로 바로 다음에 오는 순열을 찾는 문제입니다. 만약 주어진 수열이 이미 가장 마지막 순열(예: `5 4 3 2 1`)이라면, 다음 순열은 존재하지 않으므로 -1을 출력합니다.

**풀이 전략 (Next Permutation 알고리즘):**

다음 순열을 찾는 표준 알고리즘은 다음과 같은 3단계로 구성됩니다. 핵심은 '최소한으로 변경하여 다음 순열을 만드는 것'입니다.

1.  **뒤에서부터 첫 번째 감소하는 부분 찾기 (Pivot 찾기):**
    수열을 뒤에서부터 탐색하면서 `arr[i-1] < arr[i]`를 만족하는 가장 큰 `i`를 찾습니다. 즉, `arr[i-1]`은 자기 바로 뒤의 원소보다 작은 첫 번째 원소가 됩니다. 이 `arr[i-1]`을 '피벗(pivot)'이라고 부릅니다.
    *   예시: `1 2 5 4 3` 에서 `i=2`일 때 `arr[1]=2`, `arr[2]=5`이므로 `2 < 5`를 만족합니다. `arr[1]`이 피벗이 됩니다.
    *   만약 이러한 `i`를 찾지 못하고 `i`가 0이 된다면, 이는 수열이 이미 내림차순으로 정렬되어 가장 마지막 순열임을 의미합니다. 이때는 다음 순열이 없으므로 `-1`을 반환합니다.

2.  **피벗과 교환할 원소 찾기:**
    피벗 `arr[i-1]`의 오른쪽 부분(즉, `arr[i]`부터 `arr[n-1]`까지)에서 `arr[i-1]`보다 크면서 가장 작은 원소 `arr[j]`를 찾습니다.
    *   예시: `1 2 5 4 3` (피벗은 `2`) 에서 오른쪽 부분(`5 4 3`) 중 `2`보다 크면서 가장 작은 수는 `3`입니다.

3.  **교환 및 뒷부분 뒤집기:**
    *   찾은 `arr[j]`와 피벗 `arr[i-1]`을 교환(swap)합니다.
    *   교환 후, `arr[i]`부터 `arr[n-1]`까지의 부분 수열을 오름차순으로 정렬합니다. 가장 간단한 방법은 이 부분을 뒤집는(reverse) 것입니다. 왜냐하면 교환하기 전 이 부분은 내림차순으로 정렬되어 있었고, 교환 후에도 여전히 내림차순 정렬 특성이 유지되기 때문입니다. 이를 뒤집으면 가장 작은 사전순 배열이 됩니다.
    *   예시: `1 2 5 4 3` -> (피벗 `2`와 `3` 교환) -> `1 3 5 4 2` -> (오른쪽 부분 `5 4 2` 뒤집기) -> `1 3 2 4 5`. 이것이 다음 순열입니다.

이러한 단계들을 거치면 주어진 수열의 다음 순열을 효율적으로 찾을 수 있습니다.

### 2. 시간 복잡도와 공간 복잡도 분석

**시간 복잡도 (Time Complexity): O(N)**

`nextPermutation` 메서드의 각 단계는 배열을 한 번 순회하거나 그 절반을 순회하는 방식으로 이루어집니다.
*   첫 번째 `while` 루프 (`i` 찾기): 최악의 경우 배열 전체를 스캔합니다. (N번)
*   두 번째 `while` 루프 (`j` 찾기): 최악의 경우 배열의 절반을 스캔합니다. (N번)
*   `swap` 함수: O(1)
*   세 번째 `while` 루프 (뒷부분 뒤집기): 최악의 경우 배열의 절반을 스캔합니다. (N번)

따라서 `nextPermutation` 메서드는 배열의 크기 `N`에 비례하는 시간을 소요합니다. `main` 함수에서 배열 입력 및 출력도 각각 O(N)의 시간을 소요하므로, 전체 시간 복잡도는 **O(N)**이 됩니다. 이는 매우 효율적인 성능입니다.

**공간 복잡도 (Space Complexity): O(N)**

*   입력받은 수열 `arr`을 저장하기 위해 `N` 크기의 정수 배열이 필요합니다. (O(N))
*   `BufferedReader`, `StringTokenizer`, `StringBuilder` 등은 입력/출력 버퍼 및 문자열 처리를 위해 추가적인 공간을 사용하지만, 이는 일반적으로 입력 크기 `N`에 비례하거나 특정 상수를 넘지 않는 범위에서 관리되므로, 지배적인 공간 사용은 `arr` 배열에 의한 **O(N)**입니다.
*   별도의 재귀 호출이나 복사본을 만드는 과정이 없으므로 추가적인 O(N) 공간은 발생하지 않습니다.

### 3. 코드에서 개선할 점이나 주의해야 할 예외 케이스 (Edge Case)

**주의해야 할 예외 케이스 (Edge Case):**

제공된 코드는 "다음 순열" 알고리즘의 표준 구현이며, 주요 예외 케이스들을 잘 처리하고 있습니다.

1.  **가장 큰 순열인 경우 (`N, N-1, ..., 1` 형태):**
    코드의 첫 번째 `while (i > 0 && arr[i - 1] >= arr[i])` 루프에서 `i`가 0까지 감소하게 됩니다. 이 경우 `if (i == 0) return false;` 조건에 따라 `false`를 반환하고, `main` 메서드에서 `-1`을 출력하여 올바르게 처리됩니다.

2.  **N이 1인 경우:**
    `N=1`인 경우, `arr` 배열의 길이는 1입니다.
    `int i = n - 1;` 이므로 `i`는 0이 됩니다.
    `while (i > 0 && ...)` 조건은 `i > 0`이 `false`이므로 실행되지 않고, `i`는 여전히 0입니다.
    결과적으로 `if (i == 0) return false;`에 따라 `false`가 반환되고 `-1`이 출력됩니다. 이는 1개짜리 수열의 다음 순열은 존재하지 않으므로 올바른 동작입니다.

**코드에서 개선할 점 (또는 고려사항):**

1.  **주석 추가:**
    `nextPermutation` 메서드의 각 단계별로 주석을 추가하면, 처음 이 코드를 접하는 사람이나 나중에 다시 보게 될 개발자가 알고리즘의 흐름을 이해하는 데 큰 도움이 됩니다. 예를 들어:
    ```java
    private static boolean nextPermutation(int[] arr) {
        int n = arr.length;

        // 1. 뒤에서부터 첫 번째 감소하는 부분 찾기 (Pivot 찾기)
        int i = n - 1;
        while (i > 0 && arr[i - 1] >= arr[i]) {
            i--;
        }

        // 2. 만약 i가 0이라면, 이미 가장 마지막 순열이므로 다음 순열 없음
        if (i == 0) return false;

        // 3. 피벗(arr[i-1])과 교환할 원소 찾기
        //    피벗의 오른쪽 부분에서 피벗보다 크면서 가장 작은 원소 arr[j]를 찾는다.
        int j = n - 1;
        while (arr[i - 1] >= arr[j]) {
            j--;
        }

        // 4. 피벗과 찾은 원소 arr[j] 교환
        swap(arr, i - 1, j);

        // 5. 피벗의 오른쪽 부분(arr[i]부터 arr[n-1])을 오름차순으로 정렬 (뒤집기)
        int k = n - 1;
        while (i < k) {
            swap(arr, i++, k--);
        }

        return true;
    }
    ```

2.  **입력 유효성 검사 (실제 시스템 관점):**
    코딩 테스트에서는 입력이 문제 조건을 만족한다고 가정하지만, 실제 시스템에서는 `N`이 음수이거나 0일 경우, 또는 입력 문자열이 숫자로 파싱될 수 없는 경우 등에 대한 추가적인 예외 처리가 필요할 수 있습니다. (예: `N < 1`인 경우) 이 문제에서는 `N`이 양의 정수임이 보장됩니다.

3.  **`StringTokenizer` 대신 `String.split()` 사용:**
    `StringTokenizer`는 오래된 클래스이며, 경우에 따라 `String.split()`이 더 간결하고 유연하게 사용될 수 있습니다. 성능 상으로는 큰 차이가 없을 수 있지만, 최신 Java 코드에서는 `String.split()`을 더 흔하게 볼 수 있습니다. 다만, `BufferedReader`와 함께 사용할 때 `StringTokenizer`가 아주 미세하게 더 빠를 때도 있어, 경쟁 프로그래밍에서는 여전히 많이 사용됩니다. 현재 코드는 아무런 문제가 없습니다.

---

이번 포스팅에서는 "다음 순열" 문제를 풀이하는 일반적인 알고리즘과 그 구현을 분석해봤습니다. 이 알고리즘은 순열을 다루는 다양한 문제에서 유용하게 활용될 수 있으니, 꼭 기억해두시면 좋습니다. 꾸준히 연습하여 알고리즘 실력을 향상시키시길 바랍니다!

궁금한 점이 있다면 언제든지 댓글로 질문해주세요!
해피 코딩! 🚀