---
title: "[리뷰] S2_2630_색종이_만들기.java"
date: 2026-02-12
tags: [Algorithm, Java]
---

안녕하세요, 여러분! 알고리즘과 자료구조의 세계에 푹 빠져 계신가요? 오늘은 백준 온라인 저지에서 만나볼 수 있는 흥미로운 분할 정복(Divide & Conquer) 문제, **"색종이 만들기(2630번)"** 풀이를 함께 분석해보는 시간을 갖겠습니다. 이 문제는 재귀와 분할 정복의 개념을 탄탄하게 다지기에 아주 좋은 예시인데요. 제공된 Java 코드를 바탕으로 문제 요약, 풀이 전략, 시간/공간 복잡도, 그리고 개선점까지 꼼꼼하게 살펴보겠습니다.

---

## 백준 2630 색종이 만들기: 분할 정복(Divide & Conquer) 완벽 분석!

![Divide and Conquer](https://img.shields.io/badge/Algorithm-Divide%20and%20Conquer-blue?style=for-the-badge)
![Data Structure](https://img.shields.io/badge/Data%20Structure-Array-green?style=for-the-badge)
![Language](https://img.shields.io/badge/Language-Java-orange?style=for-the-badge)
![Level](https://img.shields.io/badge/Level-Silver%202-lightgrey?style=for-the-badge)

---

### 1. 문제 요약 및 풀이 전략

#### 문제 요약

N x N 크기의 종이가 주어집니다. 이 종이는 0(흰색) 또는 1(파란색)으로 채워져 있습니다.
만약 현재 종이 영역이 모두 같은 색으로 칠해져 있다면, 해당 색깔의 종이 개수를 1 증가시키고 이 영역을 종이 하나로 간주합니다.
만약 현재 종이 영역이 같은 색으로 칠해져 있지 않다면, 이 영역을 정확히 4개의 같은 크기의 정사각형 영역으로 나눈 뒤, 각 영역에 대해 동일한 과정을 반복합니다.
최종적으로 흰색 색종이와 파란색 색종이의 개수를 출력하는 문제입니다.

#### 풀이 전략: 분할 정복 (Divide & Conquer)

이 문제는 전형적인 분할 정복 알고리즘을 사용합니다. 문제의 정의 자체가 '같으면 세고, 다르면 쪼개서 다시 세라'는 형태이기 때문입니다.

1.  **재귀 함수 정의**: `divider(startX, startY, endX, endY)`
    *   현재 탐색할 정사각형 영역의 좌상단 좌표 `(startX, startY)`와 우하단 좌표 `(endX, endY)` (이때 `endX`, `endY`는 포함하지 않는, 즉 `[startX, endX)`, `[startY, endY)` 범위를 의미합니다)를 매개변수로 받습니다.
2.  **색상 확인 (Checker)**: `checker(startX, startY, endX, endY)`
    *   현재 영역이 모두 같은 색인지 확인하는 헬퍼 함수입니다.
    *   영역 내 모든 칸을 순회하며 첫 번째 칸의 색상과 다른 칸이 발견되면 `-1`을 반환하여 '다른 색이 섞여 있다'는 것을 알립니다.
    *   모든 칸이 같은 색이라면, 그 색상(0 또는 1)을 반환합니다.
3.  **분할 정복 로직**:
    *   `divider` 함수 내에서 `checker` 함수를 호출하여 현재 영역의 색상 일치 여부를 확인합니다.
    *   **Base Case (기저 사례)**:
        *   만약 `checker`가 0(흰색)을 반환하면 `white` 카운터를 증가시킵니다.
        *   만약 `checker`가 1(파란색)을 반환하면 `blue` 카운터를 증가시킵니다.
        *   이 경우 더 이상 쪼갤 필요가 없으므로 재귀를 종료합니다.
    *   **Recursive Step (재귀 호출)**:
        *   만약 `checker`가 -1을 반환하면, 현재 영역은 단일 색상이 아니므로 4등분해야 합니다.
        *   `midX = startX + (endX - startX) / 2`
        *   `midY = startY + (endY - startY) / 2`
        *   이 중간 지점을 기준으로 4개의 새로운 영역을 정의하고, 각각에 대해 `divider` 함수를 재귀 호출합니다:
            *   좌상단: `divider(startX, startY, midX, midY)`
            *   우상단: `divider(startX, midY, midX, endY)`
            *   좌하단: `divider(midX, startY, endX, midY)`
            *   우하단: `divider(midX, midY, endX, endY)`

이러한 과정을 통해 모든 N x N 영역이 1x1 크기가 되거나, 중간에 단일 색상으로 이루어진 더 큰 영역이 발견될 때까지 재귀적으로 탐색하게 됩니다.

---

### 2. 시간 복잡도와 공간 복잡도 분석

#### 시간 복잡도 (Time Complexity)

주어진 코드는 `N` x `N` 그리드를 분할 정복 방식으로 탐색합니다. 이를 `T(N)`으로 표현해봅시다.

1.  **`checker` 함수의 비용**: `k` x `k` 크기의 영역을 검사하는 데 `O(k^2)`의 시간이 소요됩니다 (모든 칸을 순회).
2.  **`divider` 함수의 재귀 관계**:
    *   `T(N)`은 `checker` 함수 호출 비용 (`O(N^2)`)과 4개의 하위 문제 재귀 호출 비용 (`4 * T(N/2)`)으로 구성됩니다.
    *   `T(N) = 4 * T(N/2) + O(N^2)`
    *   이 형태는 마스터 정리(Master Theorem)의 두 번째 케이스에 해당합니다 (a=4, b=2, f(N)=N^2, N^(log_b a) = N^(log_2 4) = N^2).
    *   따라서, 이 알고리즘의 시간 복잡도는 **`O(N^2 * log N)`** 입니다.

**설명**:
각 재귀 깊이(레벨)마다, `checker` 함수는 현재 레벨의 모든 부분 정사각형들을 검사합니다.
*   가장 상위 레벨 (N x N): 1개의 `N x N` 검사 -> `O(N^2)`
*   그 다음 레벨 (N/2 x N/2): 4개의 `(N/2) x (N/2)` 검사 -> `4 * O((N/2)^2) = 4 * O(N^2/4) = O(N^2)`
*   ...
*   최하위 레벨 (1 x 1): `N^2`개의 `1 x 1` 검사 -> `N^2 * O(1) = O(N^2)`

이러한 레벨의 수는 `log N` (N이 1이 될 때까지 2로 나누는 횟수)입니다. 따라서 총 시간 복잡도는 `O(N^2 * log N)`이 됩니다.

#### 공간 복잡도 (Space Complexity)

1.  **`grid` 배열**: 입력 `N x N` 크기의 그리드를 저장해야 하므로 `O(N^2)`의 공간이 필요합니다.
2.  **재귀 호출 스택**: `divider` 함수는 재귀적으로 호출됩니다. 최악의 경우, 매번 4등분하여 1x1 크기까지 내려가야 하므로 재귀의 깊이는 `log N`이 됩니다. 각 스택 프레임은 몇 개의 정수 변수를 저장하므로, 재귀 스택을 위한 공간은 `O(log N)`입니다.

따라서, 전체 공간 복잡도는 `grid` 배열이 지배하므로 **`O(N^2)`** 입니다.

---

### 3. 코드에서 개선할 점이나 주의해야 할 예외 케이스(Edge Case)

#### 개선할 점

1.  **전역 변수 사용**: `grid`, `blue`, `white`가 전역 변수로 선언되어 있습니다. 경쟁 프로그래밍에서는 자주 사용되는 방식이지만, 일반적인 소프트웨어 개발에서는 함수 간의 명확한 데이터 흐름을 위해 매개변수로 전달하거나, 객체 지향적으로 접근하여 클래스 내 필드로 캡슐화하는 것이 좋습니다. 이렇게 하면 코드의 재사용성이 높아지고, 예상치 못한 부작용(side effect)을 줄일 수 있습니다.
    *   예를 들어, `divider` 함수가 `blue`와 `white`를 반환하도록 하거나, 카운터 역할을 하는 클래스를 만들 수 있습니다.

2.  **매개변수 명확화**: `divider`와 `checker` 함수에서 `endX`, `endY` 대신 `size`를 매개변수로 사용하는 것이 더 직관적일 수 있습니다.
    *   현재: `divider(startX, startY, endX, endY)`
    *   개선: `divider(startX, startY, size)`
        *   `endX = startX + size`
        *   `endY = startY + size`
        *   `midX = startX + size / 2`
        *   `midY = startY + size / 2`
    *   이렇게 하면 현재 처리 중인 정사각형의 "크기"가 명확해지고, 좌표 계산도 조금 더 간결해질 수 있습니다.

3.  **상수 활용**: 마법의 숫자 `0`과 `1` 대신 `final static int WHITE = 0;`, `final static int BLUE = 1;`과 같은 상수를 선언하여 사용하면 코드의 가독성이 향상됩니다.

#### 주의해야 할 예외 케이스 (Edge Case)

1.  **N = 1 일 때**: 가장 작은 크기의 종이.
    *   `divider(0, 0, 1, 1)`이 호출됩니다.
    *   `checker(0, 0, 1, 1)`는 `grid[0][0]`의 색상을 그대로 반환합니다 (루프를 한 번만 돌고 종료).
    *   이 반환 값에 따라 `blue` 또는 `white` 카운터가 증가하고 재귀가 종료됩니다. 올바르게 처리됩니다.

2.  **전체 종이가 한 가지 색상일 때**: 예를 들어, 모든 칸이 파란색(1)인 경우.
    *   `divider(0, 0, N, N)`이 호출되고, `checker(0, 0, N, N)`는 전체 `N x N` 그리드를 검사합니다.
    *   모든 칸이 파란색임을 확인하고 `1`을 반환합니다.
    *   `blue` 카운터가 1 증가하고, 더 이상 재귀 호출 없이 종료됩니다. 이는 매우 효율적으로 처리됩니다 (`O(N^2)`).

3.  **N이 2의 거듭제곱이 아닐 때**: 문제 조건에 따라 N은 2의 거듭제곱으로 주어진다는 가정이 일반적입니다. 하지만 만약 N이 2의 거듭제곱이 아니라면, 현재 코드는 `(endX - startX) / 2` 계산에서 소수점 이하가 버려지면서 정확히 4등분 되지 않거나, 최종적으로 1x1 크기가 아닌 이상한 직사각형으로 쪼개질 수 있습니다. 이 문제의 경우 `N`은 항상 `2^k` 형태이므로 이 부분은 걱정하지 않아도 됩니다.

---

### 결론

백준 2630 "색종이 만들기" 문제는 분할 정복 알고리즘을 연습하기에 매우 좋은 문제입니다. 재귀 호출의 흐름과 기저 사례, 그리고 부분 문제를 해결하는 방식을 명확하게 이해하는 것이 중요합니다. 코드는 기본적인 분할 정복 패턴을 잘 따르고 있으며, 효율적인 입출력 방식도 사용하고 있습니다. 몇 가지 소프트웨어 공학적인 관점에서의 개선점을 고려해볼 수 있지만, 경쟁 프로그래밍 환경에서는 충분히 간결하고 효율적인 솔루션이라고 할 수 있습니다.

분할 정복은 이 외에도 퀵 정렬, 병합 정렬, 곱셈 등 다양한 알고리즘에 활용되는 강력한 패러다임이니, 이 문제를 통해 개념을 확실히 익혀두시면 앞으로 다른 복잡한 문제들을 해결하는 데 큰 도움이 될 것입니다!

Happy Coding! 💻✨