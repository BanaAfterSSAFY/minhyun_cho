---
title: "[리뷰] G4_2293_동전_1.java"
date: 2026-02-02
tags: [Algorithm, Java]
---

## 백준 2293번: 동전 1 (Coin Change II) Java 풀이 분석 - DP의 정석

안녕하세요, 알고리즘 전문가이자 기술 블로거입니다! 오늘은 백준 온라인 저지에서 많은 분들이 만나게 되는 고전적인 다이나믹 프로그래밍(DP) 문제, **2293번 '동전 1'** 문제의 Java 풀이를 함께 분석해보는 시간을 가지겠습니다. 이 문제는 '주어진 동전들로 특정 금액을 만들 수 있는 경우의 수'를 세는 대표적인 문제 유형으로, DP를 이해하는 데 매우 좋은 예시입니다.

제공해주신 코드를 살펴보며, 문제의 핵심 전략부터 시간/공간 복잡도, 그리고 놓치기 쉬운 예외 케이스까지 꼼꼼하게 파헤쳐 보겠습니다.

---

### 1. 문제 요약 및 풀이 전략

#### 문제 요약
백준 2293번 '동전 1'은 `n`가지 종류의 동전이 주어질 때, 이 동전들을 사용하여 합이 `k`원이 되도록 하는 경우의 수를 구하는 문제입니다. 각 동전은 몇 개든지 사용할 수 있으며, 동전의 순서는 중요하지 않습니다. (예: 1원짜리 2개 + 2원짜리 1개는 2원짜리 1개 + 1원짜리 2개와 같은 경우로 취급합니다.)

#### 풀이 전략: 다이나믹 프로그래밍 (Dynamic Programming)
이 문제는 전형적인 DP 문제입니다. 핵심 아이디어는 다음과 같습니다.

1.  **`dp` 배열 정의:** `dp[i]`를 "합이 `i`원이 되는 경우의 수"라고 정의합니다. 우리가 최종적으로 찾고자 하는 값은 `dp[k]`가 됩니다.
2.  **초기값 설정:** `dp[0] = 1`. 0원을 만드는 방법은 '아무 동전도 사용하지 않는' 1가지 방법이 있습니다. 이 초기값은 재귀적인 점화식을 올바르게 작동시키는 데 매우 중요합니다.
3.  **점화식 도출:** 각 동전을 하나씩 고려하면서 `dp` 배열을 업데이트합니다.
    *   현재 고려하는 동전의 가치를 `coin`이라고 합시다.
    *   `dp[j]` 값을 업데이트할 때, `j - coin`원을 만드는 방법의 수 (`dp[j - coin]`)에 `coin` 동전을 하나 추가하면 `j`원을 만들 수 있습니다.
    *   따라서, `dp[j] = dp[j] + dp[j - coin]` 이 됩니다.
        *   이전에 `coin` 동전을 고려하기 전까지 `j`원을 만들 수 있었던 방법의 수 (`dp[j]`)에,
        *   `coin` 동전을 *추가로* 사용하여 `j`원을 만드는 방법의 수 (`dp[j - coin]`)를 더해줍니다.

**코드를 통해 본 전략:**
제공된 코드에서는 `dp` 배열을 `int[] dp = new int[k + 1];`로 선언하고 `dp[0] = 1;`로 초기화합니다.
가장 중요한 부분은 이중 반복문입니다:

```java
for (int i = 0; i < n; i++) { // 각 동전에 대해 반복
    arr[i] = Integer.parseInt(br.readLine()); // 현재 동전의 가치
    for (int j = arr[i]; j < k + 1; j++) { // 현재 동전으로 만들 수 있는 금액들
        dp[j] += dp[j - arr[i]]; // 점화식 적용
    }
}
```

*   **외부 반복문 (`for (int i = 0; i < n; i++)`):** `n`개의 동전을 하나씩 순회합니다. 이 순서가 매우 중요합니다. 동전을 하나씩 고정하고, 그 동전으로 만들 수 있는 모든 합에 대해 업데이트를 진행함으로써, "조합"의 수를 세게 됩니다. (만약 이 루프와 내부 루프의 순서가 바뀌면 "순열"을 세게 될 수 있습니다.)
*   **내부 반복문 (`for (int j = arr[i]; j < k + 1; j++)`):** 현재 동전 `arr[i]`를 사용하여 만들 수 있는 금액 `j`에 대해 `dp` 값을 갱신합니다. `j`가 `arr[i]`부터 시작하는 이유는 현재 동전 `arr[i]`를 최소한 한 번 사용해야 `j`원(`arr[i]`)을 만들 수 있기 때문입니다.

이러한 접근 방식은 각 동전을 사용할지 말지를 결정하는 것이 아니라, "현재 동전을 이용하여 목표 금액 `j`를 만드는 경우의 수를 추가"하는 방식으로 작동하며, 중복 없이 모든 조합을 정확히 세게 됩니다.

---

### 2. 시간 복잡도와 공간 복잡도 분석

#### 시간 복잡도 (Time Complexity)
*   **입력 처리:** `n`과 `k`를 읽고 `n`개의 동전 값을 읽는 데 `O(N)` 시간이 소요됩니다.
*   **DP 배열 초기화:** `dp` 배열을 `k+1` 크기로 초기화하는 데 `O(K)` 시간이 소요됩니다.
*   **핵심 DP 반복문:**
    *   외부 루프: `n`번 반복 (`n`개의 동전).
    *   내부 루프: 각 동전 `arr[i]`에 대해 `arr[i]`부터 `k`까지 반복합니다. 최악의 경우 (가장 작은 동전이 1원일 때) `k`번 반복합니다.
    *   따라서, 전체 DP 계산 시간은 `O(N * K)` 입니다.

종합하면, 이 풀이의 **시간 복잡도는 `O(N * K)`** 입니다.
문제의 제약 조건 `N <= 100`, `K <= 100,000`을 고려하면, `100 * 100,000 = 10^7` 연산으로, 1~2초 내에 충분히 해결 가능한 효율적인 알고리즘입니다.

#### 공간 복잡도 (Space Complexity)
*   **`arr` 배열:** `n`개의 동전 값을 저장하는 데 `O(N)` 공간이 필요합니다.
*   **`dp` 배열:** `k+1` 크기의 배열로, `O(K)` 공간이 필요합니다.

종합하면, 이 풀이의 **공간 복잡도는 `O(N + K)`** 입니다.
`N`과 `K`의 최댓값을 기준으로 각각 `100 * sizeof(int)` 와 `100,000 * sizeof(int)`로, 약 `400B + 400KB` 정도의 메모리를 사용하므로, 메모리 제한 (일반적으로 256MB) 내에서 충분히 효율적입니다.

---

### 3. 코드에서 개선할 점이나 주의해야 할 예외 케이스 (Edge Case)

#### 1. 잠재적인 정수 오버플로우 (Integer Overflow)
*   **주의사항:** `dp` 배열이 `int` 타입으로 선언되어 있습니다. 이 문제 (`2293번`)의 `k` 최대값이 10,000이고 `n`이 100일 때, 나올 수 있는 경우의 최대 수는 `Integer.MAX_VALUE` (약 20억)를 넘지 않도록 설계되었습니다. (실제 최대값은 40만 대입니다.)
*   **개선점 (일반적인 DP 문제 시):** 만약 `k` 값이 훨씬 크거나, 동전 구성에 따라 경우의 수가 매우 빠르게 증가하는 문제라면, `dp` 배열의 타입을 `long`으로 선언하여 오버플로우를 방지해야 합니다. `dp[j] += dp[j - arr[i]];` 연산 시 합산 결과가 `int` 범위를 넘어설 수 있기 때문입니다.
    ```java
    // 예를 들어, int 대신 long[] dp = new long[k + 1];
    long[] dp = new long[k + 1];
    dp[0] = 1L; // long 타입으로 초기화
    // ...
    // dp[j] += dp[j - arr[i]]; 연산은 long 타입에서 수행됨
    ```
    *이 문제에서는 `int`로도 충분하지만, 다른 유사 문제에서는 꼭 확인해야 할 중요한 부분입니다.*

#### 2. 동전 값의 범위 (Edge Case: Coin Value)
*   **음수 동전:** 문제 조건상 동전의 가치는 항상 양수이므로 걱정할 필요 없습니다.
*   **0원 동전:** 0원짜리 동전은 의미가 없으며, 만약 입력으로 들어온다면 무한 루프나 잘못된 결과로 이어질 수 있습니다. 하지만 `acmicpc` 문제에서는 이런 식의 유효하지 않은 입력은 주어지지 않습니다.
*   **동전 값이 `k`보다 큰 경우:** 코드는 `for (int j = arr[i]; j < k + 1; j++)` 루프를 통해 `arr[i]`부터 `k`까지 탐색합니다. 만약 `arr[i]`가 `k`보다 크다면, 이 내부 루프는 한 번도 실행되지 않습니다. 이는 `arr[i]` 동전이 `k`원을 만드는 데 기여할 수 없으므로 올바르게 처리됩니다.
*   **동전 값이 중복되는 경우:** 입력으로 같은 가치의 동전이 여러 번 주어져도 (예: 1원, 1원, 2원), 이 코드는 이를 별개의 동전으로 인식하여 각각 `dp` 배열을 업데이트합니다. 하지만 문제 정의상 `n`가지 "종류"의 동전이라고 했으므로, 일반적으로 입력에 중복된 가치의 동전은 주어지지 않거나, 주어진다면 그냥 유효한 동전으로 처리하는 것이 옳습니다. 현재 코드는 이 부분을 명시적으로 처리할 필요 없이 잘 작동합니다.

#### 3. `k = 0`인 경우
*   `k = 0`이라면, `dp[0]`이 1로 초기화되어 있으므로, 출력은 `dp[0]`인 1이 됩니다. 0원을 만드는 방법은 '아무 동전도 사용하지 않는' 한 가지 방법이므로, 이는 올바른 처리입니다.

#### 4. `n = 0` (동전이 없는 경우)
*   만약 `n`이 0이라면, `for (int i = 0; i < n; i++)` 루프는 한 번도 실행되지 않습니다.
*   이 경우, `dp` 배열은 `dp[0]=1` 외에는 모두 0인 상태를 유지합니다.
*   만약 `k=0`이면 1이 출력되고, `k > 0`이면 `dp[k]` (0)이 출력됩니다. 이는 동전이 없을 때 0원 외의 다른 금액을 만들 수 없으므로 올바른 처리입니다.

#### 5. 입력 최적화
*   `BufferedReader`와 `StringTokenizer`를 사용하여 표준 입력을 효율적으로 처리하고 있습니다. 이는 경쟁 프로그래밍에서 매우 좋은 습관입니다.

---

### 마무리

백준 2293번 '동전 1' 문제는 다이나믹 프로그래밍의 기본을 탄탄히 다질 수 있는 훌륭한 문제입니다. 제공해주신 코드는 `O(N * K)`의 시간 복잡도와 `O(N + K)`의 공간 복잡도로 효율적으로 문제를 해결하고 있습니다. 특히, 동전 하나씩을 고려하며 `dp` 배열을 업데이트하는 방식은 '조합'의 수를 셀 때 매우 유용하며, 이 로직을 정확히 이해하는 것이 중요합니다.

정수 오버플로우와 같은 잠재적 문제에 대한 고려는 실전 코딩 테스트에서 디버깅 시간을 줄이고 정확한 답을 도출하는 데 큰 도움이 되므로, 항상 염두에 두시길 바랍니다.

오늘 분석한 내용이 여러분의 알고리즘 실력 향상에 도움이 되기를 바랍니다! 다음에도 더 유익한 내용으로 찾아뵙겠습니다. 감사합니다!