---
title: "[리뷰] G3_2252_줄_세우기.java"
date: 2026-02-24
tags: [Algorithm, Java]
---

안녕하세요, 알고리즘과 자료구조의 세계를 탐험하는 여러분! 오늘도 흥미로운 코딩 테스트 문제 풀이를 함께 분석해보겠습니다. 이번에 다룰 문제는 백준 2252번 "줄 세우기"입니다. 이 문제는 학생들의 키 비교 정보를 바탕으로 줄을 세우는 문제로, 전형적인 **위상 정렬(Topological Sort)** 문제라고 할 수 있습니다.

제공해주신 Java 코드를 바탕으로 문제 요약, 풀이 전략, 시간/공간 복잡도 분석, 그리고 개선점과 예외 케이스까지 꼼꼼하게 살펴보겠습니다.

---

## 백준 2252번: 줄 세우기 (G3) - 위상 정렬로 명쾌하게 해결하기!

### 1. 문제 요약 및 풀이 전략

#### 문제 요약
`N`명의 학생이 있고, `M`번의 키 비교 정보가 주어집니다. 각 비교는 "A 학생은 B 학생보다 키가 크다"는 형태로, 이는 A가 B보다 먼저 줄을 서야 함을 의미합니다. 이 모든 키 비교 정보를 만족하면서 학생들을 줄 세운 결과를 출력해야 합니다. 답이 여러 가지인 경우에는 아무거나 출력해도 됩니다.

#### 문제 접근 및 풀이 전략: 위상 정렬 (Kahn's Algorithm)
이 문제는 전형적인 작업 순서 결정 문제이며, 이를 그래프 이론으로 모델링하면 **위상 정렬**을 사용하여 해결할 수 있습니다.

1.  **그래프 모델링:**
    *   각 학생을 **노드(Node)**로 간주합니다.
    *   "A 학생이 B 학생보다 키가 크다"는 정보를 **단방향 간선(Directed Edge)**으로 표현합니다. 즉, A에서 B로 가는 간선(A -> B)을 추가합니다. 이는 'A가 B의 선행 작업'이라는 의미를 가집니다.

2.  **위상 정렬의 기본 아이디어 (Kahn's Algorithm):**
    *   **진입 차수(In-degree)** 계산: 각 노드로 들어오는 간선의 개수를 계산합니다. 진입 차수가 0인 노드는 선행되어야 할 작업(학생)이 없다는 뜻이므로, 가장 먼저 처리될 수 있습니다.
    *   **큐(Queue) 초기화:** 진입 차수가 0인 모든 노드를 큐에 넣습니다. 이들이 바로 줄의 맨 앞에 설 수 있는 후보들입니다.
    *   **정렬 과정:**
        1.  큐에서 노드 하나를 꺼냅니다. 이 노드는 현재 줄을 설 수 있는 학생 중 한 명입니다. 결과를 저장할 리스트(또는 `StringBuilder`)에 추가합니다.
        2.  꺼낸 노드와 연결된 모든 다음 노드(즉, 이 학생 뒤에 줄 서야 할 학생들)의 진입 차수를 1 감소시킵니다.
        3.  진입 차수가 0이 된 노드가 있다면, 해당 노드 역시 이제 줄을 설 수 있는 상태가 되었으므로 큐에 추가합니다.
        4.  큐가 빌 때까지 1~3번 과정을 반복합니다.

이 과정을 통해 모든 학생을 올바른 순서로 배치할 수 있습니다. 문제에서 "답이 여러 가지인 경우에는 아무거나 출력해도 된다"고 했으므로, 큐에서 노드를 꺼내는 순서에 따라 다른 유효한 위상 정렬 결과가 나올 수 있습니다. (예: 동시에 0이 된 진입 차수 노드 중 어떤 것을 먼저 꺼내느냐에 따라)

---

### 2. 시간 복잡도와 공간 복잡도 분석

제공된 코드의 효율성을 분석해 봅시다.

#### 시간 복잡도 (Time Complexity)
위상 정렬은 일반적으로 `O(V + E)`의 시간 복잡도를 가집니다. 여기서 `V`는 노드의 개수(학생 수 `N`), `E`는 간선의 개수(키 비교 수 `M`)입니다.

1.  **그래프 및 진입 차수 배열 초기화:** `ArrayList` 초기화 (`N`번), `indegree` 배열 생성 (`N`개). `O(N)`
2.  **그래프 구축 및 진입 차수 계산:** `M`개의 키 비교 정보를 처리합니다. 각 정보를 읽고 `StringTokenizer`로 파싱하며, `graph.get(u).add(v)`와 `indegree[v]++` 연산을 수행합니다. 각 간선에 대해 상수 시간 연산이므로 `O(M)`
3.  **초기 큐 삽입:** 진입 차수가 0인 노드를 찾기 위해 `N`개의 노드를 순회합니다. `O(N)`
4.  **위상 정렬 (메인 루프):**
    *   `while` 루프는 각 노드를 정확히 한 번 `q.poll()` 합니다. 따라서 `N`번 실행됩니다.
    *   내부 `for` 루프는 특정 노드와 연결된 모든 간선을 방문합니다. 모든 노드에 대한 `for` 루프의 총 실행 횟수는 그래프의 모든 간선을 한 번씩 방문하는 것과 같으므로 `O(M)`입니다.
    *   `indegree[i]--` 및 `q.offer(i)`는 상수 시간 연산입니다.

결론적으로, 모든 단계를 합산하면 `O(N + M)`의 시간 복잡도를 가집니다.
`N`은 최대 32,000, `M`은 최대 100,000이므로 `132,000` 정도의 연산으로 매우 효율적으로 동작합니다. 이는 1초 내에 충분히 해결 가능한 성능입니다.

#### 공간 복잡도 (Space Complexity)
사용되는 자료구조가 차지하는 메모리를 분석합니다.

1.  **`graph` (인접 리스트):** `N`개의 `ArrayList` 객체와 `M`개의 간선 정보를 저장합니다. `O(N + M)`
2.  **`indegree` 배열:** `N + 1` 크기의 정수 배열입니다. `O(N)`
3.  **`q` (큐):** 최악의 경우, 모든 노드가 진입 차수가 0이 되어 한꺼번에 큐에 들어갈 수 있습니다 (예: 간선이 없는 그래프). 따라서 `O(N)`
4.  **`sb` (StringBuilder):** 최종 결과를 저장하며, 최대 `N`개의 숫자를 저장합니다. `O(N)`

결론적으로, 모든 자료구조가 차지하는 공간을 합산하면 `O(N + M)`의 공간 복잡도를 가집니다.
이 역시 `N`, `M`의 최대값을 고려했을 때 충분히 감당 가능한 메모리 사용량입니다.

---

### 3. 코드에서 개선할 점이나 주의해야 할 예외 케이스 (Edge Case)

제공된 코드는 위상 정렬의 Kahn's Algorithm을 모범적으로 구현하고 있으며, 대부분의 경우에 잘 작동합니다. 하지만 몇 가지 측면에서 고려할 점이나 잠재적 예외 케이스를 짚어볼 수 있습니다.

#### 개선할 점 (코드 자체의 개선보다는 견고함 측면)

1.  **사이클 감지 (Cycle Detection):**
    *   현재 코드는 사이클을 명시적으로 감지하지 않습니다. 위상 정렬은 DAG(Directed Acyclic Graph, 방향 비순환 그래프)에서만 유효합니다. 만약 입력으로 사이클이 있는 그래프가 주어진다면 (예: A > B, B > C, C > A), `while` 루프가 끝난 후에도 큐가 비어 버리고 `sb`에는 일부 노드만 추가될 것입니다. `sb`에 추가된 노드의 개수가 `N`보다 작다면, 이는 그래프에 사이클이 존재한다는 것을 의미합니다.
    *   **현재 문제의 경우:** "줄 세우기"라는 문제의 특성상 키 비교 정보에서 논리적인 모순(사이클)이 발생하지 않는다고 암묵적으로 가정하고 있습니다. 즉, 입력은 항상 DAG라고 볼 수 있습니다. 따라서 이 문제에서는 사이클 감지가 필수적이지 않습니다.
    *   **일반적인 위상 정렬 구현 시:** `int count = 0;` 변수를 두고 노드를 하나씩 `sb.append()` 할 때마다 `count++`를 해준 뒤, 마지막에 `if (count != N) { // 사이클이 존재 }` 와 같이 체크하는 로직을 추가하는 것이 더 견고한 위상 정렬 구현입니다.

2.  **`N`이 0인 경우 (극단적인 예외):**
    *   문제 제약 조건상 `N`은 1 이상이므로 걱정할 필요는 없습니다. 하지만 `N`이 0일 경우, `indegree` 배열 초기화 및 `graph` 초기화 등에서 빈 배열/리스트에 접근하려다 오류가 발생할 수 있습니다. (물론 이 코드는 `N`이 1부터 시작하므로 `N=0`은 문제없음).

#### 주의해야 할 예외 케이스 (Edge Case)

1.  **`N = 1, M = 0` (학생 1명, 비교 없음):**
    *   `indegree[1]`은 0입니다. `1`이 큐에 들어가고 `sb`에 추가된 후 종료됩니다. `1`이 출력됩니다. 올바르게 동작합니다.

2.  **`N > 1, M = 0` (학생 여러 명, 비교 없음):**
    *   모든 `indegree[i]`는 0입니다. 모든 학생이 `for (int i = 1; i <= N; i++)` 루프에 따라 큐에 순차적으로 들어갑니다. 그리고 큐에서 꺼내지는 순서대로 `sb`에 추가됩니다. (예: 1 2 3 ... N). 문제에서 아무 순서나 가능하다고 했으므로 올바르게 동작합니다.

3.  **간선이 연결되지 않은 노드가 있는 경우 (Disjoint Graph Components):**
    *   예를 들어, 학생 1, 2, 3이 있고 (1>2) 비교만 있는 경우, 학생 3은 어떤 비교에도 참여하지 않습니다.
    *   학생 1과 3의 진입 차수는 0이므로 둘 다 큐에 먼저 들어갑니다. (큐에 1, 3 또는 3, 1이 들어감). 그 후 1이 처리되면 2의 진입 차수가 0이 되어 큐에 들어갑니다.
    *   결과적으로 `1 2 3` 또는 `3 1 2`와 같은 유효한 순서가 출력됩니다. 위상 정렬은 연결되지 않은 그래프에서도 올바르게 동작합니다.

4.  **모든 노드가 서로 연결된 경우 (Dense Graph):**
    *   `M`의 값이 `N * (N-1) / 2` 에 가까운 경우를 말합니다. `N`과 `M`의 제약 조건 내에서 `O(N + M)`의 시간 복잡도는 여전히 효율적이므로 문제 없습니다.

---

### 결론

백준 2252번 "줄 세우기" 문제는 위상 정렬의 기본기를 다지기에 아주 좋은 문제입니다. 제공해주신 Java 코드는 Kahn's Algorithm을 활용하여 이 문제를 효과적으로 해결하고 있습니다. `BufferedReader`, `StringTokenizer`, `StringBuilder` 등 입출력 최적화 기법까지 적용되어 있어 실제 코딩 테스트 환경에 최적화된 풀이입니다.

위상 정렬은 스케줄링, 빌드 시스템 의존성 관리 등 실제 소프트웨어 개발에서도 폭넓게 활용되는 중요한 알고리즘이니, 이번 기회에 확실히 이해하고 넘어가시길 바랍니다!

Happy Coding! 🚀