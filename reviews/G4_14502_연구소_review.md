---
title: "[리뷰] G4_14502_연구소.java"
date: 2026-02-02
tags: [Algorithm, Java]
---

안녕하세요, 알고리즘 매니아 여러분! 오늘은 백준 온라인 저지에서 G4 등급에 해당하는 '연구소 (14502번)' 문제 풀이 코드를 가지고 왔습니다. 이 문제는 BFS와 DFS(또는 백트래킹)를 조합하여 해결하는 대표적인 문제로, 조합 탐색과 시뮬레이션의 적절한 활용법을 배울 수 있는 좋은 예시입니다.

제가 분석할 Java 코드를 먼저 보시겠습니다.

---

### 문제 요약 및 풀이 전략

**문제 요약:**
`N x M` 크기의 연구소 지도가 주어집니다. 지도는 0(빈 칸), 1(벽), 2(바이러스)로 구성되어 있습니다. 우리는 안전 영역을 최대로 확보하기 위해 **빈 칸 3개를 골라 벽으로 세워야 합니다.** 벽을 세운 후, 바이러스는 상하좌우로 인접한 빈 칸으로 퍼져나갑니다. 모든 바이러스가 퍼진 후, 빈 칸의 개수를 세어 가장 큰 값을 찾아야 합니다.

**풀이 전략:**

이 문제는 크게 두 가지 단계로 나눌 수 있습니다.

1.  **벽 세우기 (DFS/백트래킹):** 3개의 새로운 벽을 세울 수 있는 모든 가능한 경우의 수를 탐색합니다.
    *   현재 코드는 `dfs(int wallCnt)` 함수를 사용하여 재귀적으로 벽을 세웁니다.
    *   `wallCnt`가 3이 되면, 즉 벽 3개를 모두 세웠다면, 다음 단계인 바이러스 전파 시뮬레이션을 시작합니다.
    *   벽을 세울 때는 `grid[i][j] = 1`로 표시하고 재귀 호출 후 `grid[i][j] = 0`으로 되돌려 놓는 **백트래킹** 기법을 사용하여 다음 경우의 수를 탐색할 수 있도록 원래 상태로 복구합니다.

2.  **바이러스 전파 시뮬레이션 및 안전 영역 계산 (BFS):** 3개의 벽이 세워진 특정 지도 상태에서 바이러스가 퍼지는 것을 시뮬레이션하고, 안전 영역(빈 칸)의 최대 크기를 계산합니다.
    *   `bfs()` 함수를 사용하며, 바이러스는 동시다발적으로 퍼지므로 BFS가 적합합니다.
    *   **중요:** 기존 `grid`를 직접 수정하면 벽 세우기 단계의 백트래킹에 영향을 줄 수 있으므로, `copyGrid`를 만들어 바이러스 전파를 시뮬레이션합니다.
    *   초기 바이러스 위치를 모두 큐에 넣고 BFS를 시작합니다.
    *   BFS가 끝난 후 `copyGrid`에서 `0`의 개수를 세어 안전 영역을 구하고, 현재까지의 최대 안전 영역 `ANSWER`와 비교하여 갱신합니다.

이 두 단계를 조합함으로써, 모든 벽 배치 경우의 수를 탐색하고 각 경우에 대한 최대 안전 영역을 찾을 수 있습니다.

---

### 시간 복잡도와 공간 복잡도 분석

문제의 제약 조건은 `N, M`이 최대 8입니다. 이는 `N * M`이 최대 64라는 것을 의미합니다. 이 작은 제약 덕분에 다소 높은 시간 복잡도도 허용됩니다.

**1. 시간 복잡도:**

*   **벽 세우기 (DFS):** `N * M`개의 칸 중에서 3개의 빈 칸을 선택하는 조합의 수입니다. 최악의 경우 모든 칸이 빈 칸일 때 `(N*M) C 3`이 됩니다.
    *   `K = N * M`이라고 할 때, `K C 3 = K * (K-1) * (K-2) / (3 * 2 * 1)` 입니다.
    *   최대 `64 C 3 = 41664`가지의 벽 배치 경우가 존재합니다.
    *   현재 DFS 구현 방식은 각 재귀 호출마다 `N * M`번의 반복을 수행하여 빈 칸을 찾으므로, 실제로는 `N*M * N*M * N*M`에 가까운 탐색이 이루어집니다. 하지만 이는 중복된 조합을 포함하는 탐색입니다. (개선점에서 상세히 설명)
*   **바이러스 전파 (BFS):** `N * M` 크기의 격자를 탐색하는 데 걸리는 시간은 `O(N * M)`입니다.
    *   `copyGrid`를 생성하고 값을 복사하는 데 `O(N * M)`
    *   큐 초기화 (바이러스 위치 찾기)에 `O(N * M)`
    *   BFS 탐색에 `O(N * M)`
    *   안전 영역 계산에 `O(N * M)`
    *   결론적으로 한 번의 BFS 호출은 `O(N * M)`의 시간이 소요됩니다.

*   **총 시간 복잡도:**
    `O( (N*M)^3 * N*M ) = O( (N*M)^4 )`
    (벽을 놓는 모든 `(N*M)^3` 경우의 수에 대해 각각 `O(N*M)`의 BFS를 수행)
    최대 `(8*8)^4 = 64^4 = 16,777,216` 연산입니다. 이는 1~2초의 제한 시간 내에 충분히 실행 가능한 연산량입니다.

**2. 공간 복잡도:**

*   `grid`, `copyGrid`: `O(N * M)` 크기의 2차원 배열 두 개가 필요합니다.
*   `que`: BFS 큐는 최악의 경우 모든 칸을 저장할 수 있으므로 `O(N * M)`입니다.
*   `dx`, `dy`: 상수 크기 `O(1)`.
*   DFS 재귀 스택: 벽 3개를 놓는 깊이만큼만 쌓이므로 `O(1)` (상수 3).

*   **총 공간 복잡도:** `O(N * M)`. `8 * 8 = 64`개의 정수를 저장하는 것은 매우 작은 메모리 공간이므로 충분히 허용됩니다.

---

### 코드에서 개선할 점이나 주의해야 할 예외 케이스(Edge Case)

**1. 개선할 점:**

*   **DFS를 이용한 조합 선택 최적화 (가장 중요!):**
    현재 `dfs` 함수는 벽을 놓을 때마다 처음부터 (`(0,0)`부터) 빈 칸을 찾아 나섭니다. 예를 들어, `(0,0)`에 첫 번째 벽을 놓았다면, 두 번째 벽을 놓을 때 다시 `(0,0)`부터 탐색합니다. 이는 `(0,0), (0,1), (0,2)`와 `(0,1), (0,0), (0,2)`처럼 순서만 다른 같은 조합을 여러 번 생성하게 됩니다.
    조합을 효율적으로 생성하려면, `dfs` 함수에 **이전 벽을 놓은 위치의 인덱스**를 전달하여 그 이후의 위치에서만 다음 벽을 찾도록 해야 합니다.

    ```java
    private static void dfs(int wallCnt, int startIdx) { // startIdx: 0 ~ N*M-1
        if (wallCnt == 3) {
            bfs();
            return;
        }

        // startIdx부터 탐색하여 중복 조합 방지
        for (int idx = startIdx; idx < N * M; idx++) {
            int r = idx / M;
            int c = idx % M;

            if (grid[r][c] == 0) {
                grid[r][c] = 1;
                dfs(wallCnt + 1, idx + 1); // 다음 벽은 현재 벽 다음 칸부터 탐색
                grid[r][c] = 0; // 백트래킹
            }
        }
    }
    // main 함수에서 호출: dfs(0, 0);
    ```
    이 개선을 통해 실제 탐색하는 경우의 수가 `(N*M)^3`에서 `(N*M) C 3`으로 줄어들어 실행 시간이 크게 단축됩니다. Big-O 표기법은 `O((N*M)^4)`로 같을 수 있지만, 실제 연산 횟수는 월등히 줄어듭니다.

*   **빈 칸 좌표 미리 저장:**
    만약 빈 칸의 개수가 `N*M`보다 훨씬 적다면, `dfs` 함수에서 매번 `N*M` 칸을 모두 순회하며 빈 칸을 찾는 것보다, 초기화 단계에서 모든 빈 칸의 좌표를 `ArrayList` 등에 저장해두고, 해당 리스트에서 3개의 좌표를 선택하는 방식으로 `dfs`를 구현하는 것이 효율적일 수 있습니다. (물론 이 경우에도 위의 `startIdx`를 활용한 조합 선택 기법은 동일하게 적용됩니다.)

**2. 주의해야 할 예외 케이스 (Edge Case):**

*   **3개 미만의 빈 칸:**
    만약 지도에 빈 칸이 3개 미만인 경우가 주어진다면 (문제의 제약 조건상 발생하지 않을 가능성이 높지만), `dfs` 함수는 `wallCnt == 3`에 도달하지 못하고 종료될 것입니다. 이 경우 `ANSWER`는 0으로 유지되며, 이는 안전 영역이 없음을 의미하므로 논리적으로는 문제가 없습니다. 하지만 실제 코딩 테스트에서는 명시적으로 "항상 3개 이상의 빈 칸이 주어진다"는 조건이 붙는 경우가 많습니다.

*   **초기 바이러스가 없는 경우:**
    `bfs()` 함수가 호출될 때, `que`에 아무것도 추가되지 않을 수 있습니다. `while (!que.isEmpty())` 조건에 의해 BFS 루프가 실행되지 않고, `copyGrid`는 3개의 벽이 추가된 상태 그대로 남게 되며, 모든 빈 칸이 안전 영역으로 계산될 것입니다. 이는 올바른 동작입니다.

*   **모든 칸이 바이러스 또는 벽인 경우:**
    이 경우 `dfs`는 3개의 벽을 놓지 못하거나, 놓더라도 `bfs`에서 안전 영역이 0으로 계산될 것입니다. 이 또한 논리적으로 문제없습니다.

*   **격자의 크기가 작을 때 (N, M이 1, 2 등):**
    `N`이나 `M`이 1, 2와 같이 작은 값일 때, 배열 인덱스 접근(`nx < 0 || nx >= copyGrid.length || ny < 0 || ny >= copyGrid[0].length`)에서 오류가 발생할 수 있습니다. 현재 코드는 이 경계 조건 체크를 `if`문으로 잘 처리하고 있어 문제가 없습니다.

---

### 결론

이 코드는 BFS와 DFS(백트래킹)를 조합하여 문제를 해결하는 전형적인 형태를 잘 보여줍니다. 특히, BFS를 수행할 때 원본 데이터를 훼손하지 않기 위해 `copyGrid`를 사용하는 점과 `ArrayDeque`를 사용한 큐 구현은 모범적인 사례입니다. 위에서 언급한 DFS의 조합 탐색 최적화를 적용한다면 훨씬 더 효율적인 코드가 될 것입니다. N, M의 제약이 작아 현재 코드도 통과할 가능성이 높지만, 더 큰 제약이 주어진다면 최적화는 필수적입니다.

이런 유형의 문제에 익숙해지면 다양한 그래프 탐색 및 백트래킹 문제를 해결하는 데 큰 도움이 될 것입니다. 다음에도 흥미로운 알고리즘 문제로 찾아뵙겠습니다!