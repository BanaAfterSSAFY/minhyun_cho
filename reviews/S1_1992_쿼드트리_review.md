---
title: "[리뷰] S1_1992_쿼드트리.java"
date: 2026-02-12
tags: [Algorithm, Java]
---

안녕하세요, 알고리즘과 자료구조의 세계를 탐험하는 여러분!
오늘은 백준 온라인 저지에서 만나볼 수 있는 '쿼드트리 (Quad Tree)' 문제(S1_1992)를 풀이한 Java 코드를 분석하고, 재귀와 분할 정복(Divide and Conquer) 기법이 어떻게 효과적으로 적용되는지 함께 살펴보겠습니다. 쿼드트리는 이미지 압축이나 공간 데이터 구조에 활용되는 흥미로운 개념입니다.

---

## 백준 S1 1992 쿼드트리: 재귀와 분할 정복으로 이미지 압축하기

### 1. 문제 요약 및 풀이 전략

쿼드트리 문제는 N x N 크기의 흑백 영상을 압축하는 문제입니다. 영상은 0과 1로 이루어져 있으며, 압축 규칙은 다음과 같습니다.

1.  **하나의 색상으로만 이루어진 영역:** 해당 색상(0 또는 1)으로 표현합니다.
2.  **두 가지 이상의 색상이 섞인 영역:** 해당 영역을 가로, 세로로 이등분하여 총 4개의 동일한 크기의 정사각형 영역으로 나눕니다. 그리고 각 4개의 영역을 다시 위 규칙에 따라 압축한 결과를 괄호 `()` 안에 묶어 표현합니다. 이때 4개 영역의 순서는 항상 "왼쪽 위", "오른쪽 위", "왼쪽 아래", "오른쪽 아래"입니다.

예를 들어, `((10)(01))` 같은 결과가 나올 수 있습니다.

**풀이 전략: 분할 정복 (Divide and Conquer)**

이 문제는 전형적인 **분할 정복** 알고리즘으로 해결할 수 있습니다.

*   **정복 (Conquer) / 기저 사례 (Base Case):** 주어진 현재 영역(`startX`, `startY`부터 `endX`, `endY`까지)이 모두 같은 색상(0 또는 1)으로 이루어져 있는지 확인합니다.
    *   모두 0이라면 `0`을 결과 문자열에 추가합니다.
    *   모두 1이라면 `1`을 결과 문자열에 추가합니다.
    *   이때 `checker` 함수가 이 역할을 수행합니다.
*   **분할 (Divide) / 재귀 단계 (Recursive Step):** 만약 현재 영역이 두 가지 이상의 색상으로 섞여 있다면, 이 영역을 4개의 작은 서브 영역으로 분할합니다.
    *   `(`를 결과 문자열에 추가합니다.
    *   각 서브 영역(왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래)에 대해 재귀적으로 `divider` 함수를 호출합니다.
    *   `)`를 결과 문자열에 추가합니다.

이 과정을 `N x N` 전체 영상부터 시작하여 모든 영역이 단일 색상이 될 때까지 반복하면 됩니다. `StringBuilder`를 사용하여 효율적으로 결과 문자열을 구축합니다.

### 2. 시간 복잡도와 공간 복잡도 분석

#### 시간 복잡도: O(N²)

*   **`checker` 함수:** `M x M` 크기의 서브 영역을 검사하는 데 `O(M²)`의 시간이 걸립니다. 최악의 경우, 모든 픽셀을 한 번씩 확인해야 합니다.
*   **`divider` 함수:**
    *   `divider(N, N)`은 먼저 `checker`를 호출하여 `O(N²)`의 작업을 수행합니다.
    *   만약 영역이 균일하지 않다면, 4개의 `divider(N/2, N/2)` 재귀 호출을 수행합니다.
    *   이러한 재귀 관계는 `T(N) = 4T(N/2) + O(N²) `로 표현할 수 있습니다.
    *   마스터 정리(Master Theorem)에 따르면 `a=4, b=2, f(N)=N²` 이고 `log_b(a) = log_2(4) = 2`이므로, `f(N) = N^2`는 `N^(log_b(a))`와 같습니다. 따라서 시간 복잡도는 **O(N² log N)**으로 보일 수 있습니다.

*   **하지만 실제로는 O(N²) 입니다.** 왜 그럴까요?
    *   각 레벨에서 `checker` 함수가 수행하는 총 작업량을 보면, `N x N` 그리드를 `N/2 x N/2` 서브 그리드 4개로 나누더라도, 각 서브 그리드에서 `checker`가 방문하는 픽셀들의 총합은 여전히 `N x N`에 해당합니다. 즉, 전체 N x N 픽셀 각각이 `checker` 함수에 의해 *각 재귀 레벨에서 최대 한 번씩만* 검사됩니다.
    *   이러한 방식으로 볼 때, 모든 `checker` 호출이 수행하는 총 픽셀 검사 수는 `O(N²)`. 즉, 모든 픽셀을 한 번씩만 확인하는 것과 같은 효율을 보입니다.
    *   따라서 전체 시간 복잡도는 **O(N²)**이 됩니다. (이러한 형태의 D&C 재귀는 Master Theorem Case 2에 해당하지 않고, 실질적으로는 각 픽셀이 최종적으로 하나의 균일한 블록에 속할 때까지 몇 번의 `checker` 호출에 포함될 수는 있지만, 전체 픽셀 방문 횟수는 `N^2`에 비례합니다.)

#### 공간 복잡도: O(N²)

*   **`grid` 배열:** 입력 영상을 저장하기 위해 `N x N` 크기의 2차원 배열이 필요하므로 `O(N²)`의 공간을 사용합니다.
*   **`StringBuilder` `sb`:** 최악의 경우 (모든 픽셀이 섞여 있어 재귀가 깊게 일어나는 경우), `(0(10)1(01))` 같은 형태로 결과 문자열의 길이가 `N²`에 비례하게 됩니다. 따라서 `O(N²)`의 공간이 필요합니다.
*   **재귀 스택:** 최대 재귀 깊이는 `log N` (N이 1이 될 때까지 분할). 각 스택 프레임은 소량의 변수(매개변수, 지역변수)를 저장하므로 `O(log N)`의 공간을 사용합니다.
*   종합적으로, `grid` 배열과 `StringBuilder`가 지배적이므로 전체 공간 복잡도는 **O(N²)**입니다.

### 3. 코드에서 개선할 점이나 주의해야 할 예외 케이스(Edge Case)

#### 3.1 입력 처리 효율성 개선

현재 코드에서는 `char` 배열로 읽어온 다음 `Integer.parseInt(String.valueOf(str[j]))`를 사용하여 각 문자를 정수로 변환하고 있습니다.

```java
// 현재 코드
for (int j = 0; j < N; j++) {
    grid[i][j] = Integer.parseInt(String.valueOf(str[j]));
}
```

이 방식은 `String.valueOf()`로 새로운 String 객체를 만들고, 다시 `Integer.parseInt()`를 호출하는 오버헤드가 있습니다. `char` 타입의 숫자 문자를 `int`로 변환할 때는 더 효율적인 방법이 있습니다.

**개선 방안:**

```java
// 개선된 코드
for (int j = 0; j < N; j++) {
    grid[i][j] = str[j] - '0'; // '0'은 아스키 코드 48, '1'은 49이므로 '0'을 빼면 0 또는 1이 됩니다.
}
```

이 방식은 훨씬 빠르고 메모리 효율적입니다.

#### 3.2 전역 변수 사용과 모듈성

`grid`와 `sb`를 `static` 전역 변수로 선언하고 사용하고 있습니다. 경쟁 프로그래밍에서는 코드 길이를 줄이고 매개변수 전달을 피하기 위해 흔히 사용되는 방식입니다.

```java
static int[][] grid;
static StringBuilder sb;
```

**장점:**
*   코드 작성의 편의성: 매번 `grid`와 `sb`를 함수 인자로 전달할 필요가 없어 코드가 간결해집니다.

**단점:**
*   **모듈성 저하:** 함수들이 특정 전역 상태에 강하게 의존하게 되어 재사용성이 떨어지고, 테스트하기 어려워집니다.
*   **멀티스레드 환경 문제:** 여러 스레드에서 동시에 이 코드를 실행하면 `grid`나 `sb`의 상태가 꼬일 수 있습니다 (경쟁 프로그래밍에서는 주로 싱글 스레드 환경이므로 큰 문제는 아님).

**개선 방안 (필수는 아니지만 좋은 관행):**
`grid`는 한 번 설정되면 변경되지 않으므로, `final`로 선언하거나 `main` 메서드에서 초기화 후 다른 메서드에 인자로 전달하는 것이 더 객관적인 객체 지향적 설계입니다. `sb` 역시 `divider` 메서드의 반환값으로 전달하거나, 람다식 등 함수형 접근 방식을 고려해볼 수 있습니다. 하지만 이 문제의 맥락에서는 현재 방식도 충분히 효율적입니다.

#### 3.3 예외 케이스 (Edge Case): N=1

주어진 N의 범위는 1 이상입니다. N=1인 경우, 즉 1x1 크기의 영상이 주어질 때 코드가 올바르게 동작하는지 확인해야 합니다.

*   `divider(0, 0, 1, 1)`이 호출됩니다.
*   `checker(0, 0, 1, 1)`은 `grid[0][0]` 값을 반환합니다.
*   `res`가 0 또는 1이므로, `sb.append('0')` 또는 `sb.append('1')`이 실행됩니다.
*   `else` 블록으로 가지 않으므로 분할 및 괄호 추가 작업이 일어나지 않습니다.

코드는 N=1인 경우를 완벽하게 처리하며, 별도의 예외 처리 로직이 필요 없습니다. 이는 분할 정복 알고리즘의 우아함 중 하나입니다.

### 마무리

백준 1992 쿼드트리 문제는 분할 정복 알고리즘의 기본을 익히기에 아주 좋은 문제입니다. 재귀적으로 문제를 쪼개고, 기저 사례에서 해결하며 결과를 합쳐나가는 과정이 코드에 잘 녹아들어 있습니다. 입력 처리의 작은 효율성 개선이나 전역 변수 사용에 대한 고민은 실제 프로젝트에서 코드를 작성할 때 좋은 습관으로 이어질 수 있습니다.

이 분석이 여러분의 알고리즘 학습에 도움이 되었기를 바랍니다! 다음에도 더 유익한 내용으로 찾아뵙겠습니다.