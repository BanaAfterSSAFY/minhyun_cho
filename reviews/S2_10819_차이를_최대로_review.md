---
title: "[리뷰] S2_10819_차이를_최대로.java"
date: 2026-02-06
tags: [Algorithm, Java]
---

안녕하세요, 알고리즘과 자료구조의 세계를 탐험하는 여러분!
오늘은 백준 온라인 저지 10819번 "차이를 최대로" 문제 풀이(Java)를 함께 분석해보겠습니다. 이 문제는 주어진 숫자들을 특정 순서로 나열했을 때, 인접한 두 수의 차이의 절댓값 합을 최대로 만드는 문제로, 백트래킹(Backtracking)의 기본을 탄탄히 다질 수 있는 좋은 예시입니다.

---

## 백준 10819: 차이를 최대로 - 백트래킹으로 모든 경우의 수 탐색하기

### 1. 문제 요약 및 풀이 전략

**문제 요약:**
N개의 정수가 주어졌을 때, 이 정수들을 적절히 배열하여 다음 식의 값을 최대로 만드는 프로그램을 작성하는 문제입니다.
식: `|A[0]-A[1]| + |A[1]-A[2]| + ... + |A[N-2]-A[N-1]|`

예를 들어, `[20, 1, 15, 8, 4]` 라는 숫자들이 주어졌을 때, 이 숫자들을 어떻게 배치해야 인접한 원소의 차이 절댓값 합이 최대가 될까요?

**풀이 전략: 백트래킹 (Permutation)**

N의 범위가 크지 않다는 점(보통 N! 풀이에서 N은 8~10 정도)을 고려할 때, 이 문제는 **주어진 N개의 숫자로 만들 수 있는 모든 순열(Permutation)을 생성**하고, 각 순열에 대해 주어진 식의 값을 계산하여 최댓값을 찾는 **완전 탐색(Brute Force)** 방식으로 접근할 수 있습니다.

이를 구현하기 위한 가장 대표적인 방법이 바로 **백트래킹 (Backtracking)** 입니다.

1.  **순열 생성:**
    *   재귀 함수 `dfs(index)`를 정의합니다. `index`는 현재 순열 `perm` 배열에 채워야 할 위치를 나타냅니다.
    *   `dfs(0)`부터 시작하여 `perm[0]`부터 `perm[N-1]`까지 하나씩 숫자를 채워나갑니다.
    *   `isVisited` 배열을 사용하여 이미 사용된 숫자는 다시 사용하지 않도록 체크합니다.

2.  **기저 조건 (Base Case):**
    *   `index == N`이 되면, `perm` 배열에 N개의 숫자가 모두 채워진 완전한 순열이 하나 만들어진 것입니다.
    *   이때, `for` 문을 통해 `|perm[i] - perm[i+1]|` 값을 모두 더하여 현재 순열의 합을 계산합니다.
    *   계산된 합을 `MAX_RES`와 비교하여 최댓값을 갱신합니다.

3.  **재귀 호출 (Recursive Step):**
    *   `for (int i = 0; i < N; i++)` 루프를 통해 원본 배열 `arr`의 모든 숫자를 탐색합니다.
    *   `if(isVisited[i]) continue;` 조건으로 이미 사용된 숫자는 건너뜁니다.
    *   **선택:** 현재 `arr[i]`를 `perm[index]`에 넣고 `isVisited[i] = true`로 표시합니다.
    *   **탐색:** `dfs(index + 1)`을 호출하여 다음 위치의 숫자를 채우도록 재귀합니다.
    *   **역추적 (Backtrack):** 재귀 호출이 끝난 후, `isVisited[i] = false`로 되돌려 놓아 `arr[i]`를 다음 순열에서 다시 사용할 수 있도록 합니다. (이것이 백트래킹의 핵심!)

이 과정을 통해 모든 가능한 순열을 빠짐없이 탐색하고, 최종적으로 `MAX_RES`에 저장된 값이 문제의 답이 됩니다.

```java
// 핵심 dfs 함수 구조
private static void dfs(int index) {
    // 1. 기저 조건: 순열이 완성되면 합 계산 및 최댓값 갱신
    if (index == N) {
        int sum = 0;
        for (int i = 0; i < N - 1; i++) {
            sum += Math.abs(perm[i] - perm[i + 1]);
        }
        MAX_RES = Math.max(MAX_RES, sum);
        return;
    }

    // 2. 재귀 호출: 모든 숫자 중 아직 사용하지 않은 숫자를 선택
    for (int i = 0; i < N; i++) {
        if(isVisited[i]) continue; // 이미 사용한 숫자면 건너뛰기

        isVisited[i] = true;        // 선택: 현재 숫자를 사용했다고 표시
        perm[index] = arr[i];       // 선택: perm 배열의 현재 위치에 숫자 넣기
        dfs(index + 1);             // 탐색: 다음 위치 채우러 재귀 호출
        isVisited[i] = false;       // 역추적: 다음 경우의 수를 위해 사용 표시 해제
    }
}
```

### 2. 시간 복잡도와 공간 복잡도 분석

**시간 복잡도 (Time Complexity): O(N * N!)**

*   **순열 생성:** N개의 원소로 만들 수 있는 순열의 수는 `N!` 가지입니다.
*   **각 순열 처리:** 각각의 순열이 완성될 때마다, `N-1`번의 덧셈 및 `Math.abs` 연산을 수행하여 합을 계산합니다. 이는 O(N)의 시간이 걸립니다.
*   **총 시간:** 따라서 총 시간 복잡도는 `N! * O(N)`으로, `O(N * N!)`이 됩니다.

N이 8일 경우 8! = 40,320이고, N * N! = 8 * 40,320 = 322,560이므로, 1초 내에 충분히 수행 가능한 연산량입니다. (N이 10일 경우 10! = 3,628,800, N * N! = 36,288,000으로 약간 시간이 걸릴 수 있지만, 보통 10^8 이하는 1초로 봅니다.)

**공간 복잡도 (Space Complexity): O(N)**

*   **`arr` 배열:** 입력 숫자를 저장하는 데 O(N) 공간이 필요합니다.
*   **`perm` 배열:** 현재 생성 중인 순열을 저장하는 데 O(N) 공간이 필요합니다.
*   **`isVisited` 배열:** 각 숫자의 사용 여부를 저장하는 데 O(N) 공간이 필요합니다.
*   **재귀 스택:** `dfs` 함수가 N단계까지 재귀 호출될 수 있으므로, 재귀 스택의 깊이가 최대 N이 됩니다. 이는 O(N) 공간을 사용합니다.

종합적으로, 이 풀이의 공간 복잡도는 `O(N)`입니다.

### 3. 코드에서 개선할 점이나 주의해야 할 예외 케이스(Edge Case)

**개선할 점:**

1.  **전역 변수 사용:** `arr`, `perm`, `isVisited`, `N`, `MAX_RES` 등 대부분의 변수가 `static` 전역 변수로 선언되어 있습니다. 경쟁 프로그래밍에서는 자주 사용되는 방식이지만, 일반적인 소프트웨어 개발에서는 함수 간의 명확한 데이터 흐름을 위해 매개변수로 전달하거나 클래스 멤버 변수로 캡슐화하는 것이 권장됩니다. 이 코드에서는 성능적인 이유나 간결함을 위해 선택된 것으로 보입니다.

2.  **입력 처리 효율성:** `BufferedReader`와 `StringTokenizer`를 사용하여 입력 처리 속도를 최적화했습니다. 이는 N이 커질 경우 `Scanner`보다 훨씬 효율적입니다.

3.  **최적화 가능성 (Limited):** 이 문제는 `N!`의 완전 탐색이 불가피한 전형적인 백트래킹 문제입니다. 중간에 가지치기(pruning)를 통해 탐색 공간을 줄이려는 시도는 복잡성만 높일 뿐, 실제 성능 향상에 큰 도움이 되지 않을 가능성이 높습니다. 예를 들어, 중간 합이 이미 `MAX_RES`보다 작다고 해서 그 경로를 포기할 수 없는 이유는, 나중에 더 큰 차이가 발생하여 최종 합을 뒤집을 수 있기 때문입니다. (예: `|1-10| = 9`가 `|1-2| = 1`보다 작지만 뒤에 큰 값이 오면 최종 합은 커질 수 있음)

**주의해야 할 예외 케이스 (Edge Case):**

1.  **N = 1 인 경우:**
    *   `main` 함수에서 `N`은 1이 됩니다.
    *   `dfs(0)`이 호출됩니다.
    *   `index == N` (즉, `index == 1`)이 되는 순간, `if (index == N)` 조건이 참이 됩니다.
    *   `for (int i = 0; i < N - 1; i++)` 루프는 `i < 0` 이 되므로 한 번도 실행되지 않습니다.
    *   `sum`은 초기값 0 그대로 유지됩니다.
    *   `MAX_RES = Math.max(MAX_RES, 0)` 이 되어 `MAX_RES`는 0이 됩니다.
    *   이는 N이 1일 때, 인접한 두 수의 차이를 계산할 수 없으므로 합이 0이 되는 것이 올바른 결과입니다. 현재 코드는 이 경우를 잘 처리합니다.

2.  **모든 숫자가 같은 경우:**
    *   예: `[5, 5, 5]`
    *   어떤 순열을 만들더라도 모든 `|perm[i] - perm[i+1]|`은 0이 됩니다.
    *   따라서 최종 `MAX_RES`는 0이 됩니다. 이것도 올바른 결과입니다.

3.  **음수 포함:**
    *   문제에서 주어진 정수는 음수일 수도 있습니다.
    *   `Math.abs()` 함수는 음수와 양수 모두에 대해 절댓값을 올바르게 계산해주므로, 음수가 입력으로 들어와도 문제없이 작동합니다.

---

### 마무리

백준 10819 "차이를 최대로" 문제는 백트래킹을 이용한 순열 생성의 기본을 익히기에 아주 좋은 문제입니다. N!이라는 시간 복잡도를 감당할 수 있는 N의 범위에서 완전 탐색이 필요한 경우, 이와 같은 백트래킹 패턴을 떠올릴 수 있어야 합니다.

핵심은 재귀 호출과 `isVisited` 배열을 통한 상태 관리, 그리고 **선택-탐색-역추적**의 과정입니다. 이 패턴을 잘 익혀두시면 다양한 조합 및 순열 문제 해결에 큰 도움이 될 것입니다.

질문이 있으시다면 언제든지 댓글로 남겨주세요! 다음 알고리즘 분석에서 또 만나요!