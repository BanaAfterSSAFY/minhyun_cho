---
title: "[리뷰] G3_1005_ACM_Craft.java"
date: 2026-02-25
tags: [Algorithm, Java]
---

안녕하세요, 알고리즘 매니아 여러분! 오늘은 "ACM Craft"라는 흥미로운 문제 (백준 1005번, 골드 3)를 통해 **위상 정렬(Topological Sort)**과 **동적 계획법(Dynamic Programming)**의 강력한 조합을 살펴보는 시간을 갖겠습니다. 특정 건물을 짓기 위해 필요한 최소 시간을 계산하는 문제인데요, 단순히 건물 짓는 시간만 더하는 것이 아니라, 복잡한 선행 조건까지 고려해야 합니다.

제공해주신 Java 코드를 바탕으로 이 문제의 핵심 전략과 구현 디테일을 파헤쳐 봅시다!

---

## 🏗️ ACM Craft: 위상 정렬과 DP로 최적 빌드 시간 찾기

### 1. 문제 요약 및 풀이 전략

이 문제는 N개의 건물과 M개의 건설 규칙(선행 건물)이 주어지고, 각 건물을 짓는 데 걸리는 시간이 있을 때, 특정 목표 건물 `W`를 짓기 위한 최소 총 시간을 구하는 것입니다.

**핵심 제약사항:**
*   어떤 건물을 짓기 위해서는 모든 선행 건물이 먼저 완공되어야 합니다.
*   건설 규칙은 항상 순환이 없는 형태(DAG, Directed Acyclic Graph)로 주어집니다.

이 문제는 전형적인 **DAG(Directed Acyclic Graph)에서의 최장 경로(Longest Path) 문제**로 볼 수 있으며, 이를 해결하기 위해 **위상 정렬(Topological Sort)**과 **동적 계획법(Dynamic Programming)**을 결합하는 전략이 효과적입니다.

**풀이 전략:**

1.  **그래프 표현:** 건물의 선행 관계를 방향 그래프로 표현합니다. `u`가 `v`의 선행 건물이라면, `u`에서 `v`로 가는 간선을 만듭니다. (즉, `graph.get(u).add(v)`)
2.  **진입 차수(Indegree) 계산:** 각 건물이 몇 개의 선행 건물을 가지고 있는지 `indegree` 배열에 저장합니다.
3.  **DP 배열 정의:** `dp[i]`는 `i`번 건물을 짓기 위한 **최소 총 시간** (즉, `i`번 건물을 짓는 시간 + 모든 선행 건물의 완공 시간 중 최댓값)을 저장합니다. 초기에는 `dp[i] = times[i]`로 설정합니다. (자신을 짓는 데 걸리는 최소 시간)
4.  **위상 정렬 시작:**
    *   `indegree`가 0인 건물들 (즉, 선행 건물이 없는 건물들)을 큐에 삽입합니다. 이 건물들은 즉시 건설을 시작할 수 있습니다.
    *   큐에서 건물을 하나씩 꺼내면서 다음과 같은 작업을 수행합니다.
        *   현재 건물 `curr`가 완공되었다고 가정하고, `curr`를 선행 건물로 가지는 다음 건물 `next`들에 대해 `dp` 값을 갱신합니다.
        *   **DP 점화식:** `dp[next] = Math.max(dp[next], dp[curr] + times[next])`
            *   `dp[curr]`는 `curr` 건물이 완공되는 데 걸린 총 시간입니다.
            *   `dp[curr] + times[next]`는 `curr`가 `next`의 선행 건물 중 하나일 때, `next` 건물이 `curr` 때문에 기다려야 하는 총 시간을 의미합니다.
            *   `Math.max`를 사용하는 이유는 `next` 건물이 **모든** 선행 건물이 완공될 때까지 기다려야 하므로, 가장 늦게 완공되는 선행 건물에 맞춰 시작해야 하기 때문입니다.
        *   `next` 건물의 `indegree`를 1 감소시킵니다.
        *   만약 `indegree[next]`가 0이 되면, `next` 건물도 모든 선행 건물이 완공되었으므로 큐에 삽입하여 다음 건설 대상으로 지정합니다.
5.  **결과 반환:** 목표 건물 `W`가 큐에서 빠져나올 때 `dp[W]` 값을 반환하거나, 위상 정렬이 모두 끝난 후 `dp[W]` 값을 반환합니다.

### 2. 시간 복잡도와 공간 복잡도 분석

제공된 코드의 효율성을 분석해 봅시다.

*   **시간 복잡도:**
    *   테스트 케이스의 수 `T`에 대해 반복합니다.
    *   그래프 초기화, `times`, `dp`, `indegree` 배열 초기화: `O(N)`
    *   간선 정보 입력 (`M`개) 및 `indegree` 업데이트: `O(M)`
    *   `topologySort` 함수 내부:
        *   큐 초기화: `O(N)` (모든 노드를 한 번씩 검사)
        *   `while` 루프: 각 노드는 큐에 한 번 삽입되고 한 번 추출됩니다 (`O(N)`).
        *   `for (int next : graph.get(curr))` 루프: 각 간선은 이 루프에서 한 번만 검사됩니다 (`O(M)`).
        *   따라서 위상 정렬 부분은 `O(N + M)` 입니다.
    *   **총 시간 복잡도: `O(T * (N + M))`**
    *   이 문제의 일반적인 제약 조건 (`N` 최대 1000, `M` 최대 100,000)에서 `100 * (1000 + 100000)`는 약 `10^7` 연산으로, 1초 안에 충분히 해결 가능한 효율적인 알고리즘입니다.

*   **공간 복잡도:**
    *   `graph` (인접 리스트): `O(N + M)` (N개의 리스트 객체와 M개의 간선 저장)
    *   `times`, `indegree`, `dp` 배열: 각각 `O(N)`
    *   `que`: 최악의 경우 모든 노드가 큐에 들어갈 수 있으므로 `O(N)`
    *   **총 공간 복잡도: `O(N + M)`**
    *   이 또한 제약 조건 내에서 충분히 수용 가능한 메모리 양입니다.

### 3. 코드에서 개선할 점이나 주의해야 할 예외 케이스(Edge Case)

제공된 코드는 ACM Craft 문제 해결을 위한 매우 표준적이고 효율적인 접근 방식입니다. 몇 가지 주의할 점과 특이 사항을 짚어보겠습니다.

1.  **조기 종료(Early Exit) 최적화:**
    *   `if (curr == W) return dp[curr];`
    *   이 코드는 위상 정렬 중 목표 건물 `W`가 처리될 때, 즉시 결과를 반환하여 불필요한 계산을 줄이는 최적화입니다. 위상 정렬의 특성상 `curr == W`가 되는 시점에는 `dp[W]` 값이 이미 최종적으로 결정되어 있기 때문에 가능한 최적화입니다. 만약 `W`가 그래프의 초반부에 있다면 상당한 시간을 절약할 수 있습니다. `W`가 그래프의 마지막 부분에 있다면 효과는 미미하거나 없을 수 있지만, 정확성에는 문제가 없습니다.

2.  **1-indexed 배열 사용:**
    *   `N + 1` 크기의 배열 (`times`, `indegree`, `dp`)과 `graph` 리스트를 선언하고, 인덱스를 1부터 `N`까지 사용하여 문제의 건물 번호에 직접 매핑하고 있습니다. 이는 문제 이해를 돕고 인덱스 오류를 줄이는 좋은 습관입니다. 다만, 초기화 시 0번 인덱스를 건너뛰는 것에 유의해야 합니다. (ex. `for (int i = 1; i <= N; i++)`)

3.  **Integer Overflow 가능성:**
    *   `dp` 배열의 값이 `int` 타입으로 선언되어 있습니다. `N` (건물 수)과 `times` (건설 시간)의 최댓값을 고려할 때, `N * MaxTime`이 `int`의 최댓값(약 2 * 10^9)을 넘을 수 있는지 확인해야 합니다.
    *   이 문제의 전형적인 제약 조건 (`N <= 1000`, `times <= 100000`)을 가정하면, 최대 `1000 * 100000 = 10^8` 이므로 `int` 타입으로 충분합니다. 하지만 만약 `N`이나 `times`의 제약이 훨씬 컸다면 `long` 타입을 사용해야 했을 것입니다.

4.  **예외 케이스 (Edge Cases):**
    *   **목표 건물 `W`가 선행 조건이 없는 경우:** `indegree[W]`가 0이므로 큐에 바로 삽입되고, `dp[W]`는 `times[W]`로 초기화된 값이 반환됩니다. 코드가 정상적으로 처리합니다.
    *   **N=1, M=0인 경우:** 단일 건물을 짓는 경우입니다. `W=1`일 때 `dp[1]`이 `times[1]`으로 올바르게 반환됩니다.
    *   **그래프에 사이클이 있는 경우:** 이 문제는 DAG임을 보장하기 때문에 걱정할 필요가 없지만, 만약 사이클이 존재한다면 `indegree`가 0이 되지 않는 노드가 생겨 큐가 빌 때까지 모든 노드를 처리하지 못하고 종료됩니다. 이때는 `que.isEmpty()` 후에 `if (count != N)` 등으로 사이클 존재 여부를 판단할 수 있습니다.

---

### 마무리

"ACM Craft" 문제는 위상 정렬과 동적 계획법의 아름다운 조화를 보여주는 좋은 예시입니다. 복잡한 의존 관계를 가진 작업들을 최적의 시간으로 완료해야 할 때 이 패턴을 떠올릴 수 있다면, 다양한 문제에 응용할 수 있을 것입니다. 특히 `dp` 배열의 의미와 `Math.max`를 사용하는 DP 점화식을 이해하는 것이 이 문제 해결의 핵심이라고 할 수 있겠네요!

오늘 분석한 내용이 여러분의 알고리즘 학습에 도움이 되기를 바랍니다. 다음에도 더 흥미로운 알고리즘 문제로 찾아뵙겠습니다! 🚀