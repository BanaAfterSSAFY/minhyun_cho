---
title: "[리뷰] G3_15683_감시.java"
date: 2026-02-02
tags: [Algorithm, Java]
---

안녕하세요, 알고리즘 분석가이자 기술 블로거입니다! 오늘은 백준 15683번 "감시" 문제를 Java 코드로 풀어낸 풀이를 함께 분석해보겠습니다. 이 문제는 DFS(깊이 우선 탐색)와 백트래킹의 전형적인 문제로, 모든 CCTV의 회전 방향을 조합하여 사각지대를 최소화하는 것이 목표입니다.

---

## 🔍 백준 15683: 감시 (G3) - DFS & 백트래킹으로 최적의 사각지대 찾기

### 1. 문제 요약 및 풀이 전략

"감시" 문제는 N x M 크기의 사무실에 설치된 CCTV들의 감시 방향을 적절히 설정하여 사각지대의 크기를 최소화하는 문제입니다. 사무실은 빈 공간(0), 벽(6), 그리고 1번부터 5번까지의 CCTV로 구성됩니다. CCTV마다 감시할 수 있는 방향과 회전 가능한 경우의 수가 정해져 있습니다.

이 문제는 `N, M`이 최대 8, CCTV의 개수가 최대 8개로 작기 때문에, 모든 CCTV의 가능한 모든 회전 방향 조합을 시도해보는 **완전 탐색 (Brute Force)** 방식으로 접근할 수 있습니다. 이때, 특정 CCTV의 방향을 결정하고 다음 CCTV의 방향을 결정하는 과정을 재귀적으로 탐색하는 **DFS (Depth-First Search)** 와 **백트래킹 (Backtracking)** 기법이 가장 적합합니다.

**핵심 전략:**

1.  **CCTV 유형별 감시 방향 정의:** 각 CCTV 유형(1~5번)이 가질 수 있는 모든 회전 방향 조합을 미리 `cctvDirs` 배열에 정의합니다. 예를 들어, 1번 CCTV는 상, 하, 좌, 우 4가지 방향 중 하나를 선택할 수 있습니다. 2번 CCTV는 가로(좌우), 세로(상하) 2가지 방향을 선택할 수 있습니다.
2.  **DFS 재귀 함수:**
    *   `dfs(int startR, int startC, int count)` 함수를 통해 현재 위치 `(startR, startC)`부터 시작하여 다음 CCTV를 찾아 방향을 설정하고 재귀 호출을 진행합니다. `count`는 남은 CCTV의 개수를 의미합니다.
    *   **기저 조건 (Base Case):** `count == 0` 즉, 모든 CCTV의 방향이 결정되었다면, 현재 `visited` 배열을 기반으로 사각지대(0이면서 `visited` 배열에서 감시되지 않은 곳)의 개수를 세어 `minCount`를 업데이트합니다.
    *   **CCTV 탐색 및 처리:**
        *   맵을 순회하며 아직 처리되지 않은 CCTV를 찾습니다.
        *   해당 CCTV를 발견하면, `cctvDirs` 배열에 정의된 모든 가능한 회전 방향 조합을 하나씩 시도합니다.
        *   **감시 영역 표시:** 선택된 방향에 따라 해당 CCTV가 감시하는 모든 빈 공간(`0`)에 대해 `visited` 배열의 값을 1 증가시킵니다. (`visited[x][y]++`) 이는 여러 CCTV가 한 곳을 감시할 경우를 처리하며, 백트래킹 시에 `visited` 값을 정확히 되돌리기 위함입니다.
        *   **재귀 호출:** 현재 CCTV의 방향을 설정했으므로, 다음 CCTV를 찾아 처리하기 위해 `dfs`를 재귀 호출합니다. 이때, `count - 1`로 남은 CCTV 개수를 줄이고, 다음 탐색 시작 위치도 전달합니다.
        *   **백트래킹 (원상 복구):** 재귀 호출이 끝난 후에는 현재 CCTV가 감시했던 영역에 대해 `visited` 배열의 값을 1 감소시켜 원상 복구합니다. (`visited[x][y]--`) 이는 다른 회전 방향 조합을 시도하거나, 이전 단계의 CCTV가 다른 선택을 할 수 있도록 상태를 깨끗하게 유지하는 핵심 과정입니다.

### 2. 시간 복잡도와 공간 복잡도 분석

*   **입력 크기:** `N, M <= 8`, CCTV 개수 `C <= 8`
*   **시간 복잡도:**
    *   CCTV의 최대 개수를 `C` (최대 8)라고 합시다.
    *   각 CCTV는 최대 4가지의 회전 방향(1, 3, 4번 CCTV)을 가질 수 있습니다. 2번 CCTV는 2가지, 5번 CCTV는 1가지입니다. 최악의 경우, 모든 CCTV가 4가지 방향을 가진다고 가정하면 `4^C` 가지의 조합이 발생할 수 있습니다. (`4^8 = 65,536`)
    *   DFS의 각 단계(CCTV 하나를 처리하는 과정)에서:
        *   CCTV가 감시하는 영역을 표시하는 데 걸리는 시간은 해당 CCTV가 감시할 수 있는 최대 거리(`N` 또는 `M`)와 방향의 수에 비례합니다. 한 방향으로 최악 `N` 또는 `M` 칸을 이동하며, 최대 4방향을 감시하므로 `O(N+M)` 정도가 소요됩니다.
        *   백트래킹 시 원상 복구하는 시간도 동일하게 `O(N+M)` 정도 소요됩니다.
    *   모든 CCTV의 방향이 결정된 후 사각지대를 계산하는 과정은 `O(N*M)`이 소요됩니다. 이 과정은 최종 `C`번째 CCTV가 처리된 후 딱 한 번만 실행됩니다.
    *   총 시간 복잡도는 `O( (Max_Rotation_Options)^C * (N+M) * Max_Directions + N*M )` 입니다.
    *   구체적인 값 대입: `4^8 * (8+8) * 4 + 8*8` = `65,536 * 16 * 4 + 64` ≈ `4,194,304 + 64` ≈ `4 * 10^6`
    *   이 정도 연산은 보통 1~2초의 제한 시간을 가진 코딩 테스트에서 충분히 통과할 수 있는 수준입니다.

*   **공간 복잡도:**
    *   `grid` 배열: `O(N*M)`
    *   `visited` 배열: `O(N*M)`
    *   `dx, dy, cctvDirs`: 상수 공간 `O(1)`
    *   DFS 재귀 스택: CCTV의 개수 `C`만큼 깊어지므로 `O(C)` 입니다. (최대 8)
    *   총 공간 복잡도는 `O(N*M)` 입니다. `8*8` = 64개의 정수 배열 두 개이므로 매우 효율적입니다.

### 3. 코드에서 개선할 점이나 주의해야 할 예외 케이스(Edge Case)

**👍 잘 구현된 점:**

1.  **`cctvDirs` 배열:** 각 CCTV 타입별 회전 가능한 모든 방향 조합을 3차원 배열로 깔끔하게 정리해둔 점이 인상적입니다. 이 덕분에 DFS 로직이 간결해졌습니다.
2.  **`visited` 배열 활용:** `visited[nx][ny]++` 와 `visited[nx][ny]--`를 사용하여 한 칸이 여러 CCTV에 의해 감시될 수 있는 상황을 정확하게 표현하고, 백트래킹 시 상태를 깔끔하게 원상 복구하는 데 매우 효과적입니다. `boolean` 배열 대신 `int` 배열을 사용한 것이 신의 한 수입니다.
3.  **DFS 탐색 순서:** `dfs(int startR, int startC, int count)`에서 `(i == startR ? startC : 0)`을 사용하여 현재 CCTV를 찾은 위치부터 다음 탐색을 시작하도록 한 것은 미세한 최적화입니다.

**⚠️ 주의 및 개선 제안:**

1.  **DFS 함수의 `startR`, `startC` 처리 방식:**
    현재 DFS는 `grid`를 순회하며 *다음* CCTV를 찾는 방식입니다.
    ```java
    for (int i = startR; i < N; i++) {
        for(int j = (i == startR ? startC : 0); j < M; j++) {
            if(grid[i][j] >= 1 && grid[i][j] <= 5) {
                // ... CCTV 처리 로직 ...
                return; // 하나의 CCTV를 처리했으면 이 경로에서 더 이상 다른 CCTV를 찾지 않음
            }
        }
    }
    ```
    이 방식은 모든 CCTV가 그리드에 순서대로 나타나서, `dfs`가 호출될 때마다 `startR`, `startC`부터 시작해서 *가장 먼저 만나는* CCTV를 처리하고 `return`하는 방식입니다. 이는 유효한 DFS 접근 방식이지만, 일반적으로는 모든 CCTV의 위치를 미리 `List<CCTV_Info>`와 같은 자료구조에 저장해두고, `dfs(int cctvIndex)` 와 같이 `cctvList`의 인덱스를 넘겨주는 방식이 더 명시적이고 관리하기 쉬울 수 있습니다.
    예시:
    ```java
    class CCTV {
        int r, c, type;
        public CCTV(int r, int c, int type) { this.r = r; this.c = c; this.type = type; }
    }
    static List<CCTV> cctvs = new ArrayList<>();
    // main에서 cctvs 리스트 채우기
    // dfs(0); // 첫 번째 CCTV부터 시작

    private static void dfs(int cctvIdx) {
        if (cctvIdx == cctvs.size()) { // 모든 CCTV 처리 완료
            // ... 사각지대 계산 ...
            return;
        }

        CCTV currentCCTV = cctvs.get(cctvIdx);
        int r = currentCCTV.r;
        int c = currentCCTV.c;
        int type = currentCCTV.type;

        for (int k = 0; k < cctvDirs[type].length; k++) {
            // 감시 영역 표시
            // dfs(cctvIdx + 1); // 다음 CCTV 처리
            // 백트래킹 (원상 복구)
        }
    }
    ```
    현재 코드도 동작에는 전혀 문제가 없지만, 위의 방식이 특정 상황에서 디버깅이나 이해에 더 도움이 될 수 있습니다.

2.  **초기 `cctvCount` 계산:**
    `if((num > 0) && (num < 6)) cctvCount++;` 부분은 `0` (빈 공간)과 `6` (벽)을 제외한 모든 숫자를 CCTV로 간주하여 `cctvCount`를 세는 것이므로 정확합니다.

3.  **예외 케이스 (Edge Cases):**
    *   **CCTV가 없는 경우:** `cctvCount`가 0이므로 `dfs(0, 0, 0)`이 바로 호출되어 사각지대를 정확히 계산합니다.
    *   **모든 공간이 벽 또는 CCTV인 경우:** `grid[nx][ny] == 0` 조건으로 인해 빈 공간만 `visited` 처리되므로 올바르게 동작합니다. 사각지대는 0이 됩니다.
    *   **모든 공간이 감시되는 경우:** `minCount`가 0으로 정확하게 업데이트됩니다.
    *   **경계 조건 (`nx < 0`, `ny < 0` 등):** `while` 문의 조건 (`nx >= 0 && nx < N && ny >= 0 && ny < M`)이 이를 잘 처리하고 있습니다.
    *   **벽(`6`)에 의한 시야 차단:** `grid[nx][ny] != 6` 조건이 벽을 만나면 감시를 중단하게 하여 정확하게 처리합니다.

---

### 마무리하며

백준 15683번 "감시" 문제는 DFS와 백트래킹을 활용한 완전 탐색의 좋은 예시입니다. 주어진 코드의 구현은 매우 깔끔하고 효율적이며, `cctvDirs` 배열의 설계와 `visited` 배열을 통한 상태 관리 및 백트래킹 방식은 모범적인 풀이라고 할 수 있습니다. 이 코드를 통해 DFS와 백트래킹, 그리고 배열을 이용한 상태 관리 기법을 충분히 학습할 수 있을 것입니다.

이 유형의 문제는 그리드 기반의 최적화 문제를 해결할 때 자주 사용되니, 핵심 아이디어와 구현 방식을 잘 익혀두시는 것을 추천합니다! 해피 코딩! 💻✨