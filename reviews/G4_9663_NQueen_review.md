---
title: "[리뷰] G4_9663_NQueen.java"
date: 2026-02-13
tags: [Algorithm, Java]
---

안녕하세요, 알고리즘 전문가입니다! 오늘은 백준 온라인 저지에서 골드 4 난이도로 분류된 9663번, 'N-Queen' 문제의 자바(Java) 풀이를 분석해 보겠습니다. N-Queen 문제는 백트래킹(Backtracking)의 대표적인 예시로, 재귀와 조건 검사를 통해 효율적으로 해답을 찾아나가는 과정을 배울 수 있는 중요한 문제입니다.

제시된 코드를 통해 문제 해결 전략, 시간 및 공간 복잡도, 그리고 잠재적인 개선점들을 자세히 살펴보겠습니다.

---

## ♟️ N-Queen 문제 분석 및 풀이 전략

### 1. 문제 요약

N-Queen 문제는 N x N 체스판에 N개의 퀸을 서로 공격할 수 없도록 배치하는 모든 경우의 수를 찾는 문제입니다. 퀸은 가로, 세로, 대각선 방향으로 움직일 수 있기 때문에, 어떤 두 퀸도 같은 행, 같은 열, 또는 같은 대각선에 있어서는 안 됩니다.

### 2. 풀이 전략: 백트래킹 (Backtracking)

이 문제는 모든 가능한 경우의 수를 탐색해야 하지만, 동시에 불가능한 경로를 조기에 차단하여 탐색 시간을 줄여야 합니다. 이를 위한 최적의 전략이 바로 **백트래킹**입니다.

제시된 코드는 다음과 같은 백트래킹 전략을 사용합니다:

*   **한 행에 하나의 퀸 배치:** N-Queen 문제의 특성상 각 퀸은 반드시 다른 행에 위치해야 합니다. 따라서 `depth` 변수를 현재 퀸을 놓을 행(row)으로 사용하여, `depth`가 `0`부터 `N-1`까지 증가하면서 각 행에 퀸을 하나씩 배치합니다.
*   **`grid` 배열의 활용:** `int[] grid`는 각 행에 놓인 퀸의 열(column) 위치를 저장합니다. 예를 들어, `grid[r] = c`는 `r`번째 행의 `c`번째 열에 퀸이 놓여 있음을 의미합니다.
*   **재귀 호출 (`backTracking`):**
    *   `backTracking(depth)` 함수는 `depth`번째 행에 퀸을 놓는 시도를 합니다.
    *   **종료 조건:** `depth == N`이 되면 모든 N개의 퀸을 성공적으로 배치했다는 의미이므로, 정답 카운트(`resCnt`)를 증가시키고 함수를 종료합니다.
    *   **탐색:** 현재 `depth` 행의 `i`번째 열에 퀸을 놓아보고(`grid[depth] = i`), 이 배치가 유효한지 `possible(depth)` 함수로 검사합니다.
    *   **유효성 검사 후 재귀:** 만약 `possible(depth)`가 `true`를 반환하면, `depth + 1` 행으로 이동하여 다음 퀸을 배치하기 위해 `backTracking(depth + 1)`을 재귀 호출합니다.
    *   **백트래킹:** `for` 루프가 다음 `i`로 진행되면서 자연스럽게 현재 `depth` 행의 다른 열을 시도하거나, 해당 `depth` 행에서 유효한 배치를 찾지 못하면 이전 `depth`로 돌아가 다른 열을 시도하게 됩니다.
*   **유효성 검사 (`possible`):**
    *   `possible(col)` 함수는 `col`번째 행에 놓인 퀸이 이전에 놓인 `0`부터 `col-1`번째 행의 퀸들과 충돌하는지 검사합니다.
    *   **같은 열 검사:** `grid[col] == grid[i]` (현재 퀸의 열과 이전 퀸의 열이 같은지)
    *   **같은 대각선 검사:** `Math.abs(col - i) == Math.abs(grid[col] - grid[i])` (두 퀸의 행 차이의 절대값과 열 차이의 절대값이 같은지)
    *   이 두 조건 중 하나라도 만족하면 `false`를 반환하여 유효하지 않음을 알립니다. 모든 이전에 놓인 퀸들과 충돌이 없으면 `true`를 반환합니다.

이러한 방식으로, 코드는 모든 가능한 퀸 배치 조합을 체계적으로 탐색하면서, 유효하지 않은 경로는 더 이상 탐색하지 않음으로써 탐색 공간을 효율적으로 줄여나갑니다.

---

## ⏱️ 시간 복잡도와 공간 복잡도 분석

### 1. 시간 복잡도 (Time Complexity)

N-Queen 문제의 백트래킹 시간 복잡도는 정확히 계산하기 매우 어렵습니다. 하지만 일반적인 분석은 다음과 같습니다.

*   **재귀 깊이:** `N`개의 퀸을 배치하므로 재귀 호출의 깊이는 최대 `N`입니다.
*   **각 깊이에서의 탐색:** 각 `depth`에서 `N`개의 열(`for (int i = 0; i < N; i++)`)을 시도합니다.
*   **유효성 검사 (`possible`):** `possible(col)` 함수는 현재 `col`에 도달하기까지 배치된 `col`개의 퀸들과의 충돌을 검사합니다. 이는 `O(col)` 시간이 걸리며, 최악의 경우 `O(N)`입니다.

따라서, 각 재귀 호출 단계에서 `N`번의 반복과 `O(N)`의 유효성 검사가 이루어집니다. 이는 대략적으로 `N * N * ... * N` (N번)의 형태로 보이므로 `O(N^N)`에 가까워 보일 수 있습니다.
그러나 백트래킹은 불가능한 경로를 조기에 가지치기(pruning)하기 때문에 실제 탐색하는 노드의 수는 훨씬 적습니다.

이 문제의 실제 시간 복잡도는 `N`에 대해 지수적으로 증가하며, 대략 `O(N! * N)` 또는 `O(N!)`에 가깝다고 알려져 있습니다. `N`이 15 정도까지는 수 초 내에 해결 가능하지만, `N`이 조금만 더 커져도 계산 시간이 기하급수적으로 늘어납니다.

### 2. 공간 복잡도 (Space Complexity)

*   **`grid` 배열:** `N`개의 정수를 저장하는 `int[] grid` 배열이 사용됩니다. 이는 `O(N)` 공간을 차지합니다.
*   **재귀 스택:** `backTracking` 함수는 `N`개의 퀸을 모두 배치할 때까지 재귀 호출이 발생하므로, 최대 `N`개의 스택 프레임이 쌓입니다. 이는 `O(N)` 공간을 차지합니다.

따라서, 전체 공간 복잡도는 `O(N)`입니다.

---

## 💡 코드 개선점 및 주의해야 할 예외 케이스 (Edge Case)

제시된 코드는 N-Queen 문제를 해결하는 정석적인 백트래킹 방식이며, 잘 작동합니다. 하지만 몇 가지 개선점과 고려할 예외 케이스가 있습니다.

### 1. 코드 개선점: `possible()` 함수의 효율성 증대 (O(N) -> O(1))

현재 `possible(col)` 함수는 `col`번째 퀸의 위치를 검사할 때, `0`부터 `col-1`번째 퀸들의 위치를 순회하며 `O(col)` 시간에 충돌 여부를 확인합니다. N이 커질수록 이 `O(col)` 검사가 반복되어 성능 저하의 주된 요인이 됩니다.

이 유효성 검사를 `O(1)`로 줄이는 방법은 다음과 같습니다:

*   **`boolean` 배열 활용:**
    *   `boolean[] colCheck`: 각 열(`0` ~ `N-1`)이 이미 사용되었는지 체크합니다.
    *   `boolean[] diag1Check`: 대각선(`row - col = constant`)을 체크합니다. `row - col` 값의 범위는 `-(N-1)`부터 `N-1`까지이므로, 배열 인덱스로 사용하기 위해 `row - col + (N-1)`과 같이 오프셋을 적용합니다.
    *   `boolean[] diag2Check`: 역대각선(`row + col = constant`)을 체크합니다. `row + col` 값의 범위는 `0`부터 `2N-2`까지입니다.

퀸을 `(row, col)`에 놓을 때:
1.  `colCheck[col] = true;`
2.  `diag1Check[row - col + (N-1)] = true;`
3.  `diag2Check[row + col] = true;`

퀸을 놓는 것을 철회(백트래킹)할 때:
1.  `colCheck[col] = false;`
2.  `diag1Check[row - col + (N-1)] = false;`
3.  `diag2Check[row + col] = false;`

이러한 `boolean` 배열들을 `backTracking` 함수의 인자로 전달하거나 클래스의 멤버 변수로 선언하여 활용하면, `possible` 함수가 필요 없어지고 `O(1)` 시간에 유효성 검사를 할 수 있습니다. 이 개선은 N이 큰 경우 (예: N=14, 15) 실행 시간을 크게 단축시킬 수 있습니다.

**개선된 `backTracking` 스케치:**
```java
static boolean[] colCheck;
static boolean[] diag1Check; // row - col + (N-1)
static boolean[] diag2Check; // row + col

// ... main 메소드에서 배열 초기화 ...

private static void backTracking(int row) {
    if (row == N) {
        resCnt++;
        return;
    }

    for (int col = 0; col < N; col++) {
        // O(1) 유효성 검사
        if (!colCheck[col] && !diag1Check[row - col + (N - 1)] && !diag2Check[row + col]) {
            // 퀸 배치
            colCheck[col] = true;
            diag1Check[row - col + (N - 1)] = true;
            diag2Check[row + col] = true;
            
            backTracking(row + 1); // 다음 행으로 재귀 호출

            // 퀸 제거 (백트래킹)
            colCheck[col] = false;
            diag1Check[row - col + (N - 1)] = false;
            diag2Check[row + col] = false;
        }
    }
}
```

### 2. 예외 케이스 (Edge Case)

*   **N = 0:** 문제의 제약 조건에 따라 `N`은 보통 `1` 이상의 정수로 주어집니다. 만약 `N=0`이 입력된다면, 현재 코드에서는 `N=0`일 때 `backTracking(0)`이 호출되고, 즉시 `depth == N` (`0 == 0`) 조건에 의해 `resCnt`가 1 증가하고 프로그램이 종료됩니다. 빈 체스판에 0개의 퀸을 놓는 방법은 1가지(아무것도 하지 않는 것)로 볼 수 있으므로, 이 경우에도 논리적으로는 올바른 결과입니다.
*   **N = 1:** N=1일 경우, 1x1 체스판에 퀸 하나를 놓는 방법은 1가지입니다. 코드는 `backTracking(0)` -> `grid[0]=0` -> `possible(0)` (true) -> `backTracking(1)` -> `resCnt++` -> 1을 출력합니다. 올바르게 처리됩니다.
*   **N = 2, N = 3:** 이 두 경우는 N-Queen 해답이 존재하지 않습니다. 코드는 모든 경우를 탐색한 후 `resCnt`가 0인 상태로 종료될 것이므로 올바르게 0을 출력합니다.

코드는 기본적으로 N의 양의 정수 범위 내에서 잘 작동하도록 설계되어 있습니다.

---

## 🚀 마무리하며

N-Queen 문제는 백트래킹 알고리즘의 개념과 구현을 익히는 데 매우 좋은 문제입니다. 제시된 자바 코드는 이 문제를 해결하는 기본적인 백트래킹 접근 방식을 잘 보여줍니다.

여기서 더 나아가 `boolean` 배열을 활용한 `O(1)` 유효성 검사로 최적화하는 방법을 이해하고 구현할 수 있다면, 알고리즘 실력을 한 단계 더 발전시킬 수 있을 것입니다. 단순한 재귀에서 벗어나, 상태 관리를 통해 탐색 효율을 극대화하는 방법을 고민해 보세요!

궁금한 점이 있다면 언제든지 질문해주세요!