---
title: "[리뷰] G4_6987_월드컵.java"
date: 2026-02-11
tags: [Algorithm, Java]
---

안녕하세요, 알고리즘 분석가이자 기술 블로거 [블로거 닉네임]입니다! 🚀

오늘은 백준 골드 4 난이도의 `G4_6987_월드컵` 문제를 자바 코드를 통해 분석해보는 시간을 갖겠습니다. 이 문제는 전형적인 **백트래킹 (Backtracking)** 문제로, 경우의 수를 탐색하는 능력과 효율적인 가지치기(Pruning) 전략이 중요합니다.

---

## [백준 6987번] 월드컵: 백트래킹으로 모든 가능성을 탐색하라!

### 1. 문제 요약 및 풀이 전략

**문제 요약:**
월드컵 경기가 진행된 후, 6개 팀의 최종 승/무/패 결과가 주어집니다. 각 팀은 다른 모든 팀과 한 번씩 경기를 치렀다고 가정할 때, 주어진 6개 팀의 승/무/패 기록이 **가능한 결과인지** 판단하는 문제입니다. 총 4개의 테스트 케이스에 대해 각각 `1` (가능) 또는 `0` (불가능)을 출력해야 합니다.

**풀이 전략:**

이 문제는 모든 경기의 결과를 시뮬레이션하여 주어진 승/무/패 기록과 일치하는지 확인해야 합니다. 6개 팀이 서로 한 번씩 경기를 치른다면 총 $^6C_2 = \frac{6 \times 5}{2} = 15$ 경기가 발생합니다. 각 경기는 3가지 결과(승/패, 무/무, 패/승)를 가질 수 있으므로, 단순하게 생각하면 $3^{15}$가지의 경우의 수를 모두 탐색해야 할 수 있습니다.

이러한 경우의 수 탐색에 가장 적합한 알고리즘은 **백트래킹 (Backtracking)** 입니다.

1.  **사전 검증 (Pre-Validation):**
    백트래킹을 시작하기 전에, 명백히 불가능한 경우는 미리 걸러내는 것이 매우 중요합니다.
    *   **각 팀의 총 경기 수:** 모든 팀은 5경기를 치러야 하므로, `승 + 무 + 패`의 합이 5가 아닌 팀이 있다면 즉시 `불가능`입니다.
    *   **총 승패 기록의 일치:** 전체 팀의 `총 승`의 합과 `총 패`의 합은 항상 같아야 합니다. (어떤 팀이 승리하면 다른 팀은 패배하므로)
    *   **총 무승부 기록의 짝수성:** 전체 팀의 `총 무승부`의 합은 항상 짝수여야 합니다. (어떤 경기가 무승부이면 두 팀 모두 무승부 기록이 1씩 증가하므로)

2.  **백트래킹 (DFS) 탐색:**
    사전 검증을 통과한 경우에만 `dfs` 함수를 호출하여 백트래킹을 시작합니다.
    *   **경기 순서 정의:** 6개 팀 간의 모든 15경기를 미리 `matches` 배열에 순서대로 정의해둡니다. `(0,1), (0,2), ..., (4,5)`
    *   **재귀 호출:** `dfs(round)` 함수는 `round`번째 경기를 처리합니다.
        *   **종료 조건:** `round`가 15(모든 경기 완료)가 되면, 모든 기록이 가능하게 매칭되었다는 뜻이므로 `isPossible`을 `true`로 설정하고 함수를 종료합니다.
        *   **가지치기 (Pruning):** 만약 `isPossible`이 이미 `true`라면 (다른 경로에서 이미 해답을 찾았다면), 더 이상 탐색할 필요 없이 즉시 현재 함수를 종료합니다.
        *   **경기 결과 시뮬레이션:** 현재 `round`의 두 팀(Team A, Team B)을 가져와 가능한 3가지 경기 결과를 각각 시도합니다.
            *   **Team A 승, Team B 패:**
                *   `results[A][승] > 0` 이고 `results[B][패] > 0` 이면 가능.
                *   `results[A][승]--`, `results[B][패]--` (기록 차감)
                *   `dfs(round + 1)` 호출
                *   `results[A][승]++`, `results[B][패]++` (백트래킹: 기록 원상 복구)
            *   **Team A 무, Team B 무:**
                *   `results[A][무] > 0` 이고 `results[B][무] > 0` 이면 가능.
                *   `results[A][무]--`, `results[B][무]--`
                *   `dfs(round + 1)` 호출
                *   `results[A][무]++`, `results[B][무]++`
            *   **Team A 패, Team B 승:**
                *   `results[A][패] > 0` 이고 `results[B][승] > 0` 이면 가능.
                *   `results[A][패]--`, `results[B][승]--`
                *   `dfs(round + 1)` 호출
                *   `results[A][패]++`, `results[B][승]++`
    *   어떤 경로로든 `isPossible`이 `true`가 되면, 최종적으로 `1`을 출력하고, 모든 경우를 탐색해도 `isPossible`이 `true`가 되지 않으면 `0`을 출력합니다.

### 2. 시간 복잡도와 공간 복잡도 분석

*   **시간 복잡도:**
    *   **사전 검증 부분:** 6개 팀의 기록을 순회하며 합계를 계산하는 작업은 상수 시간 `O(1)`에 해당합니다. (팀 수가 6으로 고정되어 있기 때문)
    *   **DFS (백트래킹) 부분:**
        *   총 15개의 경기가 있고, 각 경기마다 최대 3가지 결과(승-패, 무-무, 패-승)를 시도합니다.
        *   따라서 최악의 경우 $3^{15}$번의 재귀 호출이 발생할 수 있습니다.
        *   $3^{15} = 14,348,907$
        *   이 연산은 4개의 테스트 케이스에 대해 수행되므로, 총 $4 \times 3^{15} \approx 5.7 \times 10^7$ 연산이 됩니다. 이 정도 연산량은 일반적인 1~2초의 시간 제한 내에서 충분히 통과할 수 있습니다.
    *   **총 시간 복잡도:** 엄밀히 말하면 문제의 입력 크기가 고정되어 있으므로 $O(1)$ 이지만, 실질적인 연산량 관점에서는 $O(3^M)$ (M은 경기 수)으로 볼 수 있습니다.

*   **공간 복잡도:**
    *   `matches` 배열: $15 \times 2$ 크기의 `int` 배열. `O(1)`
    *   `results` 배열: $6 \times 3$ 크기의 `int` 배열. `O(1)`
    *   재귀 스택: `dfs` 호출의 최대 깊이는 15입니다. 각 스택 프레임은 소량의 변수를 저장하므로 `O(M)` (M은 경기 수) 이며, 이 역시 상수 공간 `O(1)`로 볼 수 있습니다.
    *   `BufferedReader`, `StringBuilder`, `StringTokenizer` 등의 보조 자료구조는 임시로 사용되며, 전체 공간 복잡도에 지배적인 영향을 주지 않습니다.
    *   **총 공간 복잡도:** `O(1)`

### 3. 코드에서 개선할 점이나 주의해야 할 예외 케이스(Edge Case)

**코드의 장점:**

1.  **효율적인 사전 검증:** `main` 함수에서 `totalWin != totalLose`, `totalDraw % 2 == 1`, `win + draw + lose != 5` 와 같은 조건을 먼저 체크하여 불필요한 백트래킹 탐색을 효과적으로 줄였습니다. 이는 성능 최적화에 큰 기여를 합니다.
2.  **명확한 백트래킹 구조:** 재귀 호출 전/후로 `results` 배열의 값을 정확하게 증감(`--`, `++`) 시켜 상태를 원상 복구하는 백트래킹의 기본 원칙을 잘 따르고 있습니다.
3.  **가지치기 (Pruning) 구현:** `if (isPossible) return;` 코드를 통해 한번 정답을 찾으면 더 이상 탐색하지 않고 즉시 상위 호출로 복귀하도록 구현하여 불필요한 탐색 시간을 단축합니다.
4.  **경기 대진표 미리 생성:** `matches` 배열에 모든 경기 대진표를 미리 저장해두어 DFS 내부에서 매번 대진표를 계산하는 오버헤드를 줄였습니다.

**개선할 점 (Minor):**

1.  **상수 활용:** `results` 배열의 인덱스 (`0` for win, `1` for draw, `2` for lose)를 매직 넘버 대신 `static final int WIN = 0;`, `static final int DRAW = 1;`, `static final int LOSE = 2;` 와 같은 상수로 정의하면 코드의 가독성을 더욱 높일 수 있습니다.
2.  **패키지 이름:** `Baekjoon.UnPackaged`는 일반적인 프로젝트 구조에서 권장되지 않는 패키지명입니다. (물론 코딩 테스트 환경에서는 크게 중요하지 않습니다.)

**주의해야 할 예외 케이스 (Edge Case) 및 현재 코드의 처리:**

*   **모든 팀이 0승 0무 0패인 경우:** 사전 검증 단계에서 `win + draw + lose != 5` 조건에 걸려 `isPossible = false`가 됩니다. (정상 처리)
*   **승/무/패 기록이 한쪽으로 극단적으로 치우친 경우:** 예를 들어 한 팀이 5승 0무 0패, 다른 팀들이 모두 0승으로 시작하는 경우 등. DFS는 이 모든 경우를 올바르게 탐색하고, 기록이 0보다 작아지는 것을 `if (teamA[0] > 0 && teamB[2] > 0)` 등의 조건으로 미리 방지하므로 문제가 없습니다.
*   **특정 팀의 기록이 이미 0이 되어 더 이상 경기를 할 수 없는 경우:** `teamA[X] > 0`과 같은 조건문이 이를 자연스럽게 처리합니다. 해당 기록이 0이면 해당 분기(승/무/패)로는 진행하지 않습니다.

---

**결론:**

이 `월드컵` 문제는 백트래킹의 기본 원리와 최적화 기법을 잘 보여주는 좋은 예시입니다. 특히, 백트래킹 전에 명확한 규칙들을 통해 불가능한 케이스를 걸러내는 "사전 검증" 단계와, 해답을 찾았을 때 더 이상 탐색하지 않는 "가지치기"는 백트래킹 문제 해결에 있어 필수적인 전략임을 다시 한번 상기시켜 줍니다.

여러분도 이 문제와 같은 유형의 조합 탐색 문제들을 만났을 때, 먼저 가능한 사전 조건으로 경우의 수를 줄이고, 그 다음 백트래킹을 통해 효율적으로 탐색하는 방법을 기억해두시면 큰 도움이 될 것입니다!

Happy Coding! 💻